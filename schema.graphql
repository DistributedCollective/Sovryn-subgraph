# type ContractRegistry @entity {
#   id: ID!
#   converterRegistries: [ConverterRegistry!]
#   # contracts: [BancorContract!] @derivedFrom(field: "registry")
#   owner: String
# }

type SmartToken @entity {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  # standard: String
  smartTokenType: String # Relay, Liquid, BNT?, Others?
  transfersEnabled: Boolean
  liquidityPool: LiquidityPool! @derivedFrom(field: "smartToken") # possibly v2 converter, how to handle?
  connectorTokens: [TokenSmartToken!] @derivedFrom(field: "smartToken")
  # shortestQuickBuyPath: [QuickBuyPathMember!]
  # converterWithShortestQuickBuyPath: Converter
  owner: Bytes!
  # tokenSwapTotals: [TokenSwapTotal!] @derivedFrom(field: "toToken")
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: BigInt
  addedToRegistryTransactionHash: Bytes
}

type TokenSmartToken @entity {
  id: ID! # ID is token address + smartToken address
  token: Token!
  smartToken: SmartToken!
}

type ConverterRegistry @entity {
  id: ID!
  converters: [LiquidityPool!] @derivedFrom(field: "currentConverterRegistry")
  smartTokens: [SmartToken!] @derivedFrom(field: "currentConverterRegistry")
  connectorTokens: [Token!] @derivedFrom(field: "currentConverterRegistry")
  owner: Bytes! # address
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtBlockNumber: BigInt
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtTransactionHash: String
  lastUsedAtBlockNumber: BigInt
  numConverters: BigInt!
}

type Transaction @entity {
  # txn hash
  id: ID!
  # block txn was included in
  blockNumber: BigInt!
  # timestamp txn was confirmed
  timestamp: BigInt!
  # gas used during txn execution
  # gasUsed: BigInt!
  gasPrice: BigInt!
  # tx index
  index: BigInt!
  from: Bytes!
  to: Bytes
  value: BigInt!
  gasLimit: BigInt!
}

type User @entity {
  id: ID! # address
  numSwaps: Int!
  swaps: [Swap!] @derivedFrom(field: "user")
  # tokenSwapTotals: [UserTokenSwapTotal!]
  # smartTokenBalances: [UserSmartTokenBalance!]
  # liquidityProvided: [LiquidityProvided]
}

type Token @entity {
  id: ID! #address
  name: String
  symbol: String
  decimals: Int
  version: Int
  liquidityPools: [LiquidityPoolToken!] @derivedFrom(field: "token")
  smartTokens: [TokenSmartToken!] @derivedFrom(field: "token")
  # tokenSwapTotals: [TokenSwapTotals!]
  lastPriceBtc: BigInt # TODO: Change to big decimal
  lastPriceUsd: BigInt # TODO: Change to big decimal
  # marketCap: BigInt!
  # circulatingSupply: BigInt!
  currentConverterRegistry: ConverterRegistry
}

type PoolToken @entity {
  id: ID! #address
  name: String
  symbol: String
  decimals: Int
  converters: LiquidityPoolToken! @derivedFrom(field: "poolToken") #TODO: Change to Converter entity when implemented
  underlyingAssets: [TokenPoolToken!] @derivedFrom(field: "poolToken")
}

type Swap @entity {
  id: ID! # transaction hash of the swap
  conversions: [Conversion!] @derivedFrom(field: "swapTransaction")
  numConversions: Int!
  fromToken: Bytes #TODO: Change to Token entity
  toToken: Bytes #TODO: Change to Token entity
  fromAmount: BigInt
  toAmount: BigInt
  rate: BigInt # TODO: Make this a BigDecimal
  user: User # TODO: Change to User entity
  isMarginTrade: Boolean
  isBorrow: Boolean
  timestamp: BigInt
}

type LiquidityPool @entity {
  id: ID!
  type: Int
  version: Int
  smartToken: SmartToken
  connectorTokens: [LiquidityPoolToken!]! @derivedFrom(field: "liquidityPool")
  poolTokens: [TokenPoolToken!]! @derivedFrom(field: "liquidityPool")
  owner: String
  conversionFee: BigInt
  weight: BigInt
  activated: Boolean
  # hasRBTCReserve: Boolean!
  maxConversionFee: BigInt
  # reserveRatio: Int!
  # activated: Boolean!
  # numSwaps: BigInt!
  lastResetBlockNumber: BigInt
  lastResetTimestamp: BigInt
  createdAtTimestamp: BigInt
  createdAtBlockNumber: BigInt
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
  # OTHER FIELDS TO ADD HERE
}

type LiquidityPoolToken @entity {
  id: ID! # ID is token address + liquidityPool address
  token: Token!
  liquidityPool: LiquidityPool!
  poolToken: PoolToken!
}

type TokenPoolToken @entity {
  id: ID! # ID is token address + poolToken address
  token: Token!
  poolToken: PoolToken!
  liquidityPool: LiquidityPool!
}

#### GENERATED BY SCAFFOLD SCRIPT - Add any custom entities before this line

type OwnerUpdate @entity {
  id: ID!
  _prevOwner: Bytes! # address
  _newOwner: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
type NewConverter @entity {
  id: ID!
  _type: Int! # uint16
  _converter: Bytes! # address
  _owner: Bytes! # address
  timestamp: BigInt!
  transaction: Transaction!
}

type ConverterAnchorAdded @entity {
  id: ID!
  _anchor: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ConverterAnchorRemoved @entity {
  id: ID!
  _anchor: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LiquidityPoolAdded @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LiquidityPoolRemoved @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ConvertibleTokenAdded @entity {
  id: ID!
  _convertibleToken: Bytes! # address
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ConvertibleTokenRemoved @entity {
  id: ID!
  _convertibleToken: Bytes! # address
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SmartTokenAdded @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SmartTokenRemoved @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PriceDataUpdate @entity {
  id: ID!
  _connectorToken: Bytes! # address
  _tokenSupply: BigInt! # uint256
  _connectorBalance: BigInt! # uint256
  _connectorWeight: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LiquidityAdded @entity {
  id: ID!
  _provider: Bytes! # address
  _reserveToken: Bytes! # address
  _amount: BigInt! # uint256
  _newBalance: BigInt! # uint256
  _newSupply: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LiquidityRemoved @entity {
  id: ID!
  _provider: Bytes! # address
  _reserveToken: Bytes! # address
  _amount: BigInt! # uint256
  _newBalance: BigInt! # uint256
  _newSupply: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Activation @entity {
  id: ID!
  _type: Int! # uint16
  _anchor: Bytes! # address
  _activated: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Conversion @entity {
  id: ID!
  _fromToken: Bytes! # address
  _toToken: Bytes! # address
  _trader: Bytes! # address
  _amount: BigInt! # uint256
  _return: BigInt! # uint256
  _conversionFee: BigInt! # int256
  _protocolFee: BigInt! # int256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  swapTransaction: Swap!
}

type TokenRateUpdate @entity {
  id: ID!
  _token1: Bytes! # address
  _token2: Bytes! # address
  _rateN: BigInt! # uint256
  _rateD: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ConversionFeeUpdate @entity {
  id: ID!
  _prevFee: BigInt! # uint32
  _newFee: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type WithdrawFees @entity {
  id: ID!
  sender: Bytes! # address
  receiver: Bytes! # address
  token: Bytes! # address
  protocolFeeAmount: BigInt! # uint256
  wRBTCConverted: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type DynamicFeeFactorUpdate @entity {
  id: ID!
  _prevFactor: BigInt! # uint256
  _newFactor: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
type Approval @entity {
  id: ID!
  owner: Bytes! # address
  spender: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Transfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
