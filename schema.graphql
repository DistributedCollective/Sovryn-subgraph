"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats @entity {
  """
  Only one entity should be created, with ID "0"
  """
  id: ID!
  """
  An array of all tokens in the protocol
  """
  tokens: [Token!]!
  usdStablecoin: Token!
  btcUsdPrice: BigDecimal!
  """
  Total number of users of the protocol. This number is incremented each time a user is created
  """
  totalUsers: BigInt!
  """
  Total of positionSize property in Trade event (in usd)
  """
  totalMarginTradeVolumeUsd: BigDecimal!
  totalCloseWithSwapVolumeUsd: BigDecimal!
  totalDepositCollateralVolumeUsd: BigDecimal!
  totalLiquidateVolumeUsd: BigDecimal!
  totalAmmVolumeUsd: BigDecimal!
  totalAmmLpFeesUsd: BigDecimal!
  totalAmmStakerFeesUsd: BigDecimal!
  totalTradingFeesUsd: BigDecimal!
  totalLendingFeesUsd: BigDecimal!
  totalBorrowingFeesUsd: BigDecimal!
  totalLendVolumeUsd: BigDecimal!
  totalUnlendVolumeUsd: BigDecimal!
  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: BigDecimal!
  totalCloseWithDepositVolumeUsd: BigDecimal!
  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  totalVoluntarilyStakedSov: BigInt!
  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  totalStakedByVestingSov: BigInt!
  totalTransactedVolumeUsd: BigInt! # TODO: Implement
}

type UserTotals @entity {
  id: ID!
  user: User!
  totalMarginTradeVolumeUsd: BigDecimal!
  totalCloseWithSwapVolumeUsd: BigDecimal!
  totalDepositCollateralVolumeUsd: BigDecimal!
  totalLiquidateVolumeUsd: BigDecimal!
  totalAmmVolumeUsd: BigDecimal!
  totalAmmLpFeesUsd: BigDecimal!
  totalAmmStakerFeesUsd: BigDecimal!
  totalTradingFeesUsd: BigDecimal!
  totalLendingFeesUsd: BigDecimal!
  totalBorrowingFeesUsd: BigDecimal!
  totalLendVolumeUsd: BigDecimal!
  totalUnlendVolumeUsd: BigDecimal!
  totalBorrowVolumeUsd: BigDecimal!
  totalCloseWithDepositVolumeUsd: BigDecimal!
  totalTransactedVolumeUsd: BigInt! # TODO: Implement
}

type SmartToken @entity {
  """
  ID is smart token address
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String # Relay, Liquid, BNT?, Others?
  transfersEnabled: Boolean
  liquidityPool: LiquidityPool! @derivedFrom(field: "smartToken")
  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens: [TokenSmartToken!] @derivedFrom(field: "smartToken")
  owner: Bytes!
  # tokenSwapTotals: [TokenSwapTotal!] @derivedFrom(field: "toToken")
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: BigInt
  addedToRegistryTransactionHash: Bytes
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken @entity {
  """
  ID is token address + smart token address
  """
  id: ID!
  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
  smartToken: SmartToken!
}

type ConverterRegistry @entity {
  """
  ID is the address of the converter registry contract
  """
  id: ID!
  converters: [LiquidityPool!] @derivedFrom(field: "currentConverterRegistry")
  smartTokens: [SmartToken!] @derivedFrom(field: "currentConverterRegistry")
  connectorTokens: [Token!] @derivedFrom(field: "currentConverterRegistry")
  owner: Bytes! # address
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtBlockNumber: BigInt
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtTransactionHash: String
  lastUsedAtBlockNumber: BigInt
  numConverters: BigInt!
}

"""
Transaction data, including hash and timestamp
"""
type Transaction @entity {
  """
  ID is transaction hash
  """
  id: ID!
  blockNumber: BigInt!
  # timestamp txn was confirmed
  timestamp: BigInt!
  # gas used during txn execution
  # gasUsed: BigInt!
  gasPrice: BigInt!
  # tx index
  index: BigInt!
  from: Bytes! # TODO: Change to User entity
  to: Bytes
  value: BigInt!
  gasLimit: BigInt!
}

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User @entity {
  """
  ID is user wallet address
  """
  id: ID!
  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps: [Swap!] @derivedFrom(field: "user")
  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory: [UserLiquidityHistory!] @derivedFrom(field: "user")
  """
  An array of margin trade Trade events
  """
  trades: [Trade!] @derivedFrom(field: "user")
  """
  An array of Borrow events
  """
  borrows: [Borrow!] @derivedFrom(field: "user")
  """
  An array of Liquidation events linked to this user
  """
  liquidations: [Liquidate!] @derivedFrom(field: "user")
  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans: [Loan!] @derivedFrom(field: "user")
  """
  An array of all Mint and Burn events
  """
  lendingHistory: [UserLendingHistory!] @derivedFrom(field: "user")
  dividendsCollected: [DividendsCollected!] @derivedFrom(field: "receiver")
  """
  An array of Stake, Unstake, Extend Stake and Withdraw Stake actions
  """
  stakeHistory: [UserStakeHistory!] @derivedFrom(field: "user")
  rewardsEarnedHistory: [UserRewardsEarnedHistory!] @derivedFrom(field: "user")
  # feesEarnedHistory: [UserFeesEarnedHistory!] @derivedFrom(field: "user")
  # vestedTokensWithdrawn: [TokensWithdrawn!] @derivedFrom(field: "receiver")
  """
  Vesting contracts owned by this user
  """
  vestingContracts: [VestingContract!] @derivedFrom(field: "user")
  votes: [VoteCast!] @derivedFrom(field: "voter")
  userTotals: UserTotals @derivedFrom(field: "user")
}

type UserLendingHistory @entity {
  id: ID! # user address + lending pool
  user: User!
  lendingPool: LendingPool!
  lendingHistory: [LendingHistoryItem!] @derivedFrom(field: "userLendingHistory")
  totalLendVolume: BigInt!
  totalUnlendVolume: BigInt!
}

type LendingHistoryItem @entity {
  id: ID! # tx hash
  lender: User!
  type: String! # Lend or Unlend
  lendingPool: LendingPool!
  asset: Token # this is nullable because context is not working properly currently
  amount: BigInt!
  loanTokenAmount: BigInt!
  transaction: Transaction!
  emittedBy: String!
  userLendingHistory: UserLendingHistory!
}

type Token @entity {
  id: ID! @unique
  name: String
  symbol: String
  decimals: Int
  version: Int
  liquidityPools: [LiquidityPoolToken!] @derivedFrom(field: "token")
  smartTokens: [TokenSmartToken!] @derivedFrom(field: "token")
  # tokenSwapTotals: [TokenSwapTotals!]
  """
  previous BTC price used for candleSticks
  """
  prevPriceBtc: BigDecimal!
  lastPriceBtc: BigDecimal!
  """
  previous BTC price used for candleSticks
  """
  prevPriceUsd: BigDecimal!
  lastPriceUsd: BigDecimal!
  btcVolume: BigDecimal!
  usdVolume: BigDecimal!
  tokenVolume: BigDecimal!
  # marketCap: BigInt!
  # circulatingSupply: BigInt!
  currentConverterRegistry: ConverterRegistry
  hasBtcPool: Boolean
  hasStablecoinPool: Boolean
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken @entity {
  id: ID! #address
  name: String
  symbol: String
  decimals: Int
  converters: [LiquidityPoolToken!] @derivedFrom(field: "poolToken") #TODO: Does this need a many-to-many relationship?
  underlyingAssets: [TokenPoolToken!] @derivedFrom(field: "poolToken")
}

type Swap @entity {
  id: ID! # transaction hash of the swap
  conversions: [Conversion!] @derivedFrom(field: "swapTransaction")
  numConversions: Int!
  fromToken: Token!
  toToken: Token!
  fromAmount: BigDecimal!
  toAmount: BigDecimal!
  rate: BigDecimal!
  user: User
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  timestamp: BigInt!
  transaction: Transaction!
}

type LiquidityPool @entity {
  id: ID!
  type: Int
  version: Int
  smartToken: SmartToken
  token0: Token
  token1: Token
  connectorTokens: [LiquidityPoolToken!]! @derivedFrom(field: "liquidityPool")
  poolTokens: [TokenPoolToken!]! @derivedFrom(field: "liquidityPool")
  owner: String
  conversionFee: BigInt
  weight: BigInt
  activated: Boolean
  # hasRBTCReserve: Boolean!
  maxConversionFee: BigInt
  # reserveRatio: Int!
  # activated: Boolean!
  # numSwaps: BigInt!
  lastResetBlockNumber: BigInt
  lastResetTimestamp: BigInt
  createdAtTimestamp: BigInt
  createdAtBlockNumber: BigInt
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
  # OTHER FIELDS TO ADD HERE
}

type LiquidityPoolToken @entity {
  id: ID! # ID liquidityPool address + tokenAddress
  token: Token!
  liquidityPool: LiquidityPool!
  poolToken: PoolToken!
  # balance: BigInt! # Balance is hard to implement because pools were initially funded not throught the LiquidityAdded event
  volumeBought: BigDecimal!
  volumeSold: BigDecimal!
  totalVolume: BigDecimal!
}

type TokenPoolToken @entity {
  id: ID! # ID is token address + poolToken address
  token: Token!
  poolToken: PoolToken!
  liquidityPool: LiquidityPool!
}

# Loans
enum LoanType {
  Trade
  Borrow
}

type Loan @entity {
  id: ID! # ID is LoanId
  loanToken: Token!
  collateralToken: Token!
  type: LoanType!
  startTimestamp: BigInt!
  endTimestamp: BigInt
  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: BigDecimal!
  startBorrowedAmount: BigDecimal!
  maxBorrowedAmount: BigDecimal!

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: BigDecimal!
  startPositionSize: BigDecimal!
  maximumPositionSize: BigDecimal!
  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: BigDecimal!
  isOpen: Boolean!
  user: User
  trade: [Trade!] @derivedFrom(field: "loanId")
  borrow: [Borrow!] @derivedFrom(field: "loanId")
  closeWithSwaps: [CloseWithSwap!] @derivedFrom(field: "loanId")
  closewithDeposits: [CloseWithDeposit!] @derivedFrom(field: "loanId")
  liquidates: [Liquidate!] @derivedFrom(field: "loanId")
  depositCollateral: [DepositCollateral!] @derivedFrom(field: "loanId")
  totalBought: BigDecimal!
  totalSold: BigDecimal!
  averageBuyPrice: BigDecimal!
  averageSellPrice: BigDecimal!
  """
  The realised PnL is quoted in the collateral currency
  """
  realizedPnL: BigDecimal!
  realizedPnLPercent: BigDecimal!
}

# Lending

# TODO: implement this entity
type LendingPool @entity {
  id: ID! # ID is the pool token
  underlyingAsset: Token!
  poolTokenBalance: BigInt!
  assetBalance: BigInt!
  """
  Total asset volume lent over all time
  """
  totalAssetLent: BigInt!
}

#### GENERATED BY SCAFFOLD SCRIPT - Add any custom entities before this line

type NewConverter @entity {
  id: ID!
  _type: Int! # uint16
  _converter: Bytes! # address
  _owner: Bytes! # address
  timestamp: BigInt!
  transaction: Transaction!
}

type LiquidityPoolAdded @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LiquidityPoolRemoved @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SmartTokenAdded @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SmartTokenRemoved @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PriceDataUpdate @entity {
  id: ID!
  _connectorToken: Bytes! # address
  _tokenSupply: BigInt! # uint256
  _connectorBalance: BigInt! # uint256
  _connectorWeight: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type UserLiquidityHistory @entity {
  id: ID! # user + '-' + smartToken
  user: User!
  poolToken: PoolToken!
  totalAsset0LiquidityAdded: BigInt!
  totalAsset0LiquidityRemoved: BigInt!
  totalAsset1LiquidityAdded: BigInt!
  totalAsset1LiquidityRemoved: BigInt!
  liquidityHistory: [LiquidityHistoryItem!] @derivedFrom(field: "userLiquidityHistory")
}

type LiquidityHistoryItem @entity {
  id: ID! # transaction hash + log index
  user: User!
  userLiquidityHistory: UserLiquidityHistory!
  type: String! # Added or removed
  provider: String! # address
  reserveToken: Token! # address
  amount: BigInt! # uint256
  newBalance: BigInt! # uint256
  newSupply: BigInt! # uint256
  timestamp: BigInt!
  liquidityPool: LiquidityPool!
  emittedBy: String! #address
  transaction: Transaction!
}

type Activation @entity {
  id: ID!
  _type: Int! # uint16
  _anchor: Bytes! # address
  _activated: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Conversion @entity {
  id: ID!
  _fromToken: Token! # address
  _toToken: Token! # address
  _trader: Bytes! # address
  _amount: BigInt! # uint256
  _return: BigInt! # uint256
  _conversionFee: BigInt! # int256
  _protocolFee: BigInt! # int256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  swapTransaction: Swap!
}

type TokenRateUpdate @entity {
  id: ID!
  _token1: Bytes! # address
  _token2: Bytes! # address
  _rateN: BigInt! # uint256
  _rateD: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ConversionFeeUpdate @entity {
  id: ID!
  _prevFee: BigInt! # uint32
  _newFee: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type WithdrawFees @entity {
  id: ID!
  sender: Bytes! # address
  receiver: Bytes! # address
  token: Bytes! # address
  protocolFeeAmount: BigInt! # uint256
  wRBTCConverted: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Approval @entity {
  id: ID!
  owner: Bytes! # address
  spender: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Transfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Sovryn Protocol Events
type Borrow @entity {
  id: ID!
  user: User! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  newPrincipal: BigInt! # uint256
  newCollateral: BigInt! # uint256
  interestRate: BigInt! # uint256
  interestDuration: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type CloseWithDeposit @entity {
  id: ID!
  user: Bytes! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  closer: Bytes! # address
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  repayAmount: BigInt! # uint256
  collateralWithdrawAmount: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type CloseWithSwap @entity {
  id: ID!
  user: Bytes! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  collateralToken: Bytes! # address
  loanToken: Bytes! # address
  closer: Bytes! # address
  positionCloseSize: BigInt! # uint256
  loanCloseAmount: BigInt! # uint256
  exitPrice: BigInt! # uint256
  currentLeverage: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type DepositCollateral @entity {
  id: ID!
  loanId: Loan! # bytes32
  depositAmount: BigInt! # uint256
  rate: BigInt # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type EarnReward @entity {
  id: ID!
  receiver: User! # address
  token: Token! # address
  loanId: Loan! # bytes32
  feeRebatePercent: BigInt! # uint256
  amount: BigInt! # uint256
  basisPoint: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Liquidate @entity {
  id: ID!
  user: User! # address
  liquidator: Bytes! # address
  loanId: Loan! # bytes32
  lender: Bytes! # address
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  repayAmount: BigInt! # uint256
  collateralWithdrawAmount: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LoanSwap @entity {
  id: ID!
  loanId: Loan! # bytes32
  sourceToken: Bytes! # address
  destToken: Bytes! # address
  borrower: Bytes! # address
  sourceAmount: BigInt! # uint256
  destAmount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PayBorrowingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  loanId: Loan! # bytes32
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PayLendingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PayTradingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  loanId: Loan! # bytes32
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PayTradingFeeToAffiliate @entity {
  id: ID!
  referrer: Bytes! # address
  trader: Bytes! # address
  token: Bytes! # address
  isHeld: Boolean! # bool
  tradingFeeTokenAmount: BigInt! # uint256
  tokenBonusAmount: BigInt! # uint256
  sovBonusAmount: BigInt! # uint256
  sovBonusAmountPaid: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PayTradingFeeToAffiliateFail @entity {
  id: ID!
  referrer: Bytes! # address
  trader: Bytes! # address
  token: Bytes! # address
  tradingFeeTokenAmount: BigInt! # uint256
  tokenBonusAmount: BigInt! # uint256
  sovBonusAmount: BigInt! # uint256
  sovBonusAmountTryingToPaid: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ProtocolModuleContractReplaced @entity {
  id: ID!
  prevModuleContractAddress: Bytes! # address
  newModuleContractAddress: Bytes! # address
  module: Bytes! # bytes32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetAffiliateFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetAffiliateTradingTokenFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetAffiliatesReferrer @entity {
  id: ID!
  user: Bytes! # address
  referrer: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetAffiliatesReferrerFail @entity {
  id: ID!
  user: Bytes! # address
  referrer: Bytes! # address
  alreadySet: Boolean! # bool
  userNotFirstTrade: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetBorrowingFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetFeesController @entity {
  id: ID!
  sender: Bytes! # address
  oldController: Bytes! # address
  newController: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetLendingFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetLiquidationIncentivePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetLoanPool @entity {
  id: ID!
  sender: Bytes! # address
  loanPool: Bytes! # address
  underlying: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SetWrbtcToken @entity {
  id: ID!
  sender: Bytes! # address
  oldWethToken: Bytes! # address
  newWethToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Trade @entity {
  id: ID!
  user: User! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  collateralToken: Bytes! # address
  loanToken: Bytes! # address
  positionSize: BigInt! # uint256
  borrowedAmount: BigInt! # uint256
  interestRate: BigInt! # uint256
  settlementDate: BigInt! # uint256
  entryPrice: BigInt! # uint256
  entryLeverage: BigInt! # uint256
  currentLeverage: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Lending Contract events

type WithdrawLendingFees @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type WithdrawTradingFees @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Burn @entity {
  id: ID!
  user: User! # address
  tokenAmount: BigInt! # uint256
  assetAmount: BigInt! # uint256
  lendingPool: LendingPool!
  price: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  underlyingAsset: Token!
}

type FlashBorrow @entity {
  id: ID!
  user: User! # address
  target: Bytes! # address
  loanAmount: BigInt! # uint256
  lendingPool: LendingPool!
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  underlyingAsset: Token!
}

type Mint @entity {
  id: ID!
  user: User! # address
  tokenAmount: BigInt! # uint256
  assetAmount: BigInt! # uint256
  lendingPool: LendingPool!
  price: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Vesting Resistry

type VestingContract @entity {
  id: ID! # vesting contract id
  user: User!
  createdAtTimestamp: BigInt!
  cliff: BigInt # uint256
  duration: BigInt # uint256
  startingBalance: BigInt! # uint256
  currentBalance: BigInt!
  type: String! # Team, Non-team, Rewards, Fish
  emittedBy: Bytes!
  createdAtTransaction: Transaction!
  stakeHistory: [TokensStaked!]!
  # sovTransferred: [SOVTransferred!] @derivedFrom(field: "receiver")
}

type SOVTransferred @entity {
  id: ID!
  receiver: VestingContract! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# VestingLogic

type DividendsCollected @entity {
  id: ID!
  caller: Bytes! # address
  loanPoolToken: Bytes! # address
  receiver: User! # address
  maxCheckpoints: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensWithdrawn_Vesting @entity {
  id: ID!
  caller: Bytes! # address
  receiver: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Staking contract

type DelegateStakeChanged @entity {
  id: ID!
  delegate: Bytes! # address
  lockedUntil: BigInt! # uint256
  previousBalance: BigInt! # uint256
  newBalance: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensStaked @entity {
  id: ID!
  user: User
  staker: Bytes! # address
  amount: BigInt! # uint256
  lockedUntil: BigInt! # uint256
  totalStaked: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  isUserStaked: Boolean!
}

type VestingTokensWithdrawn @entity {
  id: ID!
  vesting: VestingContract! # address
  receiver: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# This maps to existing stakeHistory api

type UserStakeHistory @entity {
  id: ID! # id is user
  user: User!
  stakeHistory: [StakeHistoryItem!] @derivedFrom(field: "user")
  totalStaked: BigInt!
  totalWithdrawn: BigInt!
  totalRemaining: BigInt!
}

type StakeHistoryItem @entity {
  id: ID! # transaction hash
  user: UserStakeHistory!
  action: String!
  timestamp: BigInt!
  transaction: Transaction!
  amount: BigInt
  lockedUntil: BigInt
}

# Fee Sharing Proxy and Fees History
type UserRewardsEarnedHistory @entity {
  id: ID! # user
  user: User!
  totalFeesAndRewardsEarned: BigInt!
  availableTradingRewards: BigInt!
  availableRewardSov: BigInt!
  rewardsEarnedHistory: [RewardsEarnedHistoryItem!] @derivedFrom(field: "user")
}

type RewardsEarnedHistoryItem @entity {
  id: ID! # transaction hash
  action: String!
  user: UserRewardsEarnedHistory!
  token: Token
  amount: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
}

type FeeAMMWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  converter: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type FeeWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensTransferred @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type UserFeeWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  receiver: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Locked SOV

type Deposited @entity {
  id: ID!
  _initiator: Bytes! # address
  _userAddress: Bytes! # address
  _sovAmount: BigInt! # uint256
  _basisPoint: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Mining Proxy

type RewardClaimed @entity {
  id: ID!
  user: Bytes! # address
  poolToken: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Staking Reward

type RewardWithdrawn @entity {
  id: ID!
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# TokenConverted

type TokenConverted @entity {
  id: ID!
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Candlesticks

enum CandleSticksInterval {
  MinuteInterval
  FifteenMintuesInterval
  HourInterval
  FourHourInterval
  DayInterval
}

type CandleStick @entity {
  id: ID! # fromToken + toToken + timestamp + interval
  baseToken: Token
  quoteToken: Token
  interval: CandleSticksInterval
  open: BigDecimal # opening price
  high: BigDecimal! # high price
  low: BigDecimal! # low price
  close: BigDecimal! # close price
  txCount: Int! # number of transactions during period
  totalVolume: BigDecimal! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}

# Governor Contracts
type Proposal @entity {
  id: ID! # contract address + id
  created: Transaction!
  canceled: Transaction
  executed: Transaction
  queued: Transaction
  votesFor: BigInt!
  votesAgainst: BigInt!
  countVotersFor: BigInt!
  countVotersAgainst: BigInt!
  votes: [VoteCast!] @derivedFrom(field: "proposal")
  proposalId: BigInt!
  proposer: Bytes! # address
  targets: [String!]! # address[]
  values: [BigInt!]! # uint256[]
  signatures: [String!]! # string[]
  startBlock: BigInt! # uint256
  endBlock: BigInt! # uint256
  description: String! # string
  timestamp: BigInt!
  emittedBy: Bytes! #address
}

type VoteCast @entity {
  id: ID!
  voter: User! # address
  proposalId: BigInt! # uint256
  proposal: Proposal!
  support: Boolean! # bool
  votes: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
