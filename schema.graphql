"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users. 
The ID of this one entity is "0"
"""
type ProtocolStats @entity {
  """
  Only one entity should be created, with ID "0"
  """
  id: ID!
  """
  An array of all tokens in the protocol
  """ 
  tokens: [Token!]!
  usdStablecoin: Token!
  btcUsdPrice: BigDecimal!
  """
  Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
  Currently this is incremented by specific user actions, but could be incremented on a per Transaction basis.
  """
  totalUsers: BigInt!
  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: BigDecimal!
  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: BigDecimal!
  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: BigDecimal!
  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: BigDecimal!
  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: BigDecimal!
  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: BigDecimal!
  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: BigDecimal!
  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: BigDecimal!
  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: BigDecimal!
  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: BigDecimal!
  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: BigDecimal!
  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: BigDecimal!
  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: BigDecimal!
  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: BigDecimal!
  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  totalVoluntarilyStakedSov: BigInt!
  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  totalStakedByVestingSov: BigInt!
  """
  NOT YET IMPLEMENTED: This will be a total of volumes of all transaction types (AMM Swaps, Margin Trades, CloseWithSwap etc etc)
  """
  totalTransactedVolumeUsd: BigInt! # TODO: Implement
}

"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotals @entity {
  id: ID!
  user: User!
  totalMarginTradeVolumeUsd: BigDecimal!
  totalCloseWithSwapVolumeUsd: BigDecimal!
  totalDepositCollateralVolumeUsd: BigDecimal!
  totalLiquidateVolumeUsd: BigDecimal!
  totalAmmVolumeUsd: BigDecimal!
  totalAmmLpFeesUsd: BigDecimal!
  totalAmmStakerFeesUsd: BigDecimal!
  totalTradingFeesUsd: BigDecimal!
  totalLendingFeesUsd: BigDecimal!
  totalBorrowingFeesUsd: BigDecimal!
  totalLendVolumeUsd: BigDecimal!
  totalUnlendVolumeUsd: BigDecimal!
  totalBorrowVolumeUsd: BigDecimal!
  totalCloseWithDepositVolumeUsd: BigDecimal!
  totalTransactedVolumeUsd: BigInt! # TODO: Implement
}

"""
The smart token represents a single reserve asset on a single pool. 
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken @entity {
  """
  ID is smart token address
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String # Relay, Liquid, BNT?, Others?
  transfersEnabled: Boolean
  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool! @derivedFrom(field: "smartToken")
  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens: [TokenSmartToken!] @derivedFrom(field: "smartToken")
  owner: Bytes!
  # tokenSwapTotals: [TokenSwapTotal!] @derivedFrom(field: "toToken")
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: BigInt
  addedToRegistryTransactionHash: Bytes
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken @entity {
  """
  ID is token address + smart token address
  """
  id: ID!
  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
  smartToken: SmartToken!
}

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry @entity {
  """
  ID is the address of the converter registry contract
  """
  id: ID!
  """
  All the converters (AMM pools) associated with this registry
  """
  converters: [LiquidityPool!] @derivedFrom(field: "currentConverterRegistry")
  smartTokens: [SmartToken!] @derivedFrom(field: "currentConverterRegistry")
  connectorTokens: [Token!] @derivedFrom(field: "currentConverterRegistry")
  owner: Bytes! # address
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtBlockNumber: BigInt
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtTransactionHash: String
  lastUsedAtBlockNumber: BigInt
  numConverters: BigInt!
}

"""
Transaction data, including hash and timestamp
"""
type Transaction @entity {
  """
  ID is transaction hash
  """
  id: ID!
  blockNumber: BigInt!
  """
  The timestamp the transaction was confirmed
  """
  timestamp: BigInt!
  gasPrice: BigInt!
  """
  The index of this transaction within the block
  """
  index: BigInt!
  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: Bytes! # TODO: Change to User entity
  to: Bytes
  value: BigInt!
  gasLimit: BigInt!
}

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User @entity {
  """
  ID is user wallet address
  """
  id: ID!
  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included. 
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps: [Swap!] @derivedFrom(field: "user")
  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory: [UserLiquidityHistory!] @derivedFrom(field: "user")
  """
  An array of margin trade Trade events
  """
  trades: [Trade!] @derivedFrom(field: "user")
  """
  An array of Borrow events
  """
  borrows: [Borrow!] @derivedFrom(field: "user")
  """
  An array of Liquidation events linked to this user
  """
  liquidations: [Liquidate!] @derivedFrom(field: "user")
  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans: [Loan!] @derivedFrom(field: "user")
  """
  The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events.
  """
  lendingHistory: [UserLendingHistory!] @derivedFrom(field: "user")
  """
  The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory: [UserStakeHistory!] @derivedFrom(field: "user")
  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory: [UserRewardsEarnedHistory!] @derivedFrom(field: "user")
  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts: [VestingContract!] @derivedFrom(field:"user")
  """
  Voting history of User
  """
  votes: [VoteCast!] @derivedFrom(field: "voter")
  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotals @derivedFrom(field: "user")
}

"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory @entity {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!
  user: User!
  lendingPool: LendingPool!
  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory: [LendingHistoryItem!] @derivedFrom(field: "userLendingHistory")
  """
  Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: BigInt!
  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: BigInt!
}

"""
Granular Lend/Unlend events
"""
type LendingHistoryItem @entity {
  id: ID! # tx hash
  lender: User!
  type: String! # Lend or Unlend
  """
  The LendingPool (iToken/poolToken) address 
  """
  lendingPool: LendingPool!
  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token 
  amount: BigInt! #TODO: Change to BigDecimal
  loanTokenAmount: BigInt!
  transaction: Transaction!
  emittedBy: String!
  userLendingHistory: UserLendingHistory!
}

"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token @entity {
  """
  The ID is the contract address of the token on RSK
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools: [LiquidityPoolToken!] @derivedFrom(field: "token")
  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens: [TokenSmartToken!] @derivedFrom(field: "token")
  # tokenSwapTotals: [TokenSwapTotals!]
  """
  The last traded price of this token in BTC
  """
  lastPriceBtc: BigDecimal!
  """
  The last traded price of this token in USD
  """
  lastPriceUsd: BigDecimal!
  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: BigDecimal!
  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: BigDecimal!
  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: BigDecimal!
  # marketCap: BigInt!
  # circulatingSupply: BigInt!
  currentConverterRegistry: ConverterRegistry
  """
  Does this token have an AMM pool with rBTC as the other reserve asset?
  """
  hasBtcPool: Boolean
  """
  Does this token have an AMM pool with the protocol stablecoin as the other reserve asset?
  """
  hasStablecoinPool: Boolean
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken @entity {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  """
  The AMM pool that this PoolToken "belongs" to
  """
  converters: LiquidityPoolToken! @derivedFrom(field: "poolToken") #TODO: Does this need a many-to-many relationship?
  """
  The ERC20 asset or assets represented by this token
  """
  underlyingAssets: [TokenPoolToken!] @derivedFrom(field: "poolToken")
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap @entity {
  """
  Transaction hash of this swap
  """
  id: ID!
  """
  The AMM Conversion events involved in this swap
  """
  conversions: [Conversion!] @derivedFrom(field: "swapTransaction")
  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!
  fromToken: Token! 
  toToken: Token!
  fromAmount: BigDecimal!
  toAmount: BigDecimal!
  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: BigDecimal!
  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null
  """
  user: User
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  timestamp: BigInt!
  transaction: Transaction!
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool @entity {
  """
  ID is the contract address of the Converter
  """
  id: ID!
  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
  smartToken: SmartToken
  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token
  token1: Token
  connectorTokens: [LiquidityPoolToken!]! @derivedFrom(field: "liquidityPool")
  poolTokens: [TokenPoolToken!]! @derivedFrom(field: "liquidityPool")
  owner: String
  conversionFee: BigInt
  weight: BigInt
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  # hasRBTCReserve: Boolean!
  maxConversionFee: BigInt
  # reserveRatio: Int!
  # activated: Boolean!
  # numSwaps: BigInt!
  lastResetBlockNumber: BigInt
  lastResetTimestamp: BigInt
  createdAtTimestamp: BigInt
  createdAtBlockNumber: BigInt
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
  # OTHER FIELDS TO ADD HERE
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and so
"""
type LiquidityPoolToken @entity {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  token: Token!
  liquidityPool: LiquidityPool!
  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  # balance: BigInt! # Balance is hard to implement because pools were initially funded not through the LiquidityAdded event
  """
  Total volumes of this token bought and sold in this liquidity pool over all time
  """
  volumeBought: BigInt!
  volumeSold: BigInt!
  totalVolume: BigInt!
}

"""
The entity stores the many-to-many relationship between underlying tokens and pool tokens
"""
type TokenPoolToken @entity {
  """
  ID is token address + poolToken address
  """
  id: ID! 
  token: Token!
  poolToken: PoolToken!
  liquidityPool: LiquidityPool!
}

# Loans
enum LoanType {
  Trade
  Borrow
}

"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan @entity {
  id: ID! # ID is LoanId
  loanToken: Token!
  collateralToken: Token!
  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!
  startTimestamp: BigInt!
  endTimestamp: BigInt
  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: BigDecimal!
  startBorrowedAmount: BigDecimal!
  maxBorrowedAmount: BigDecimal!

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: BigDecimal!
  """
  Initial size of the position
  """
  startPositionSize: BigDecimal!
  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: BigDecimal!
  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: BigDecimal!
  """
  If a Liquidate, CloseWithSwap or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!
  user: User
  trade: [Trade!] @derivedFrom(field: "loanId")
  borrow: [Borrow!] @derivedFrom(field: "loanId")
  closeWithSwaps: [CloseWithSwap!] @derivedFrom(field: "loanId")
  closewithDeposits: [CloseWithDeposit!] @derivedFrom(field: "loanId")
  liquidates: [Liquidate!] @derivedFrom(field: "loanId")
  depositCollateral: [DepositCollateral!] @derivedFrom(field: "loanId")
  totalBought: BigDecimal!
  totalSold: BigDecimal!
  averageBuyPrice: BigDecimal!
  averageSellPrice: BigDecimal!
  """
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: BigDecimal!
  realizedPnLPercent: BigDecimal!
}

"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool @entity {
  """
  ID is the contract address of the iToken
  """
  id: ID! 
  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
  """
  Current amount of pool tokens that exist (incremented with Mint events, decremented with Burn events)
  """
  totalPoolTokenMinted: BigInt!
  totalPoolTokenBurned: BigInt!
  """
  Total amount of the underlying asset that has been lent through this pool over all time
  """
  totalAssetLent: BigInt!
  """
  Total amount of the underlying asset that has been unlent (withdrawn) from this pool over all time
  """
  totalAssetUnLent: BigInt!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type NewConverter @entity {
  id: ID!
  _type: Int! # uint16
  _converter: Bytes! # address
  _owner: Bytes! # address
  timestamp: BigInt!
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolAdded @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolRemoved @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenAdded @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenRemoved @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type PriceDataUpdate @entity {
  id: ID!
  _connectorToken: Bytes! # address
  _tokenSupply: BigInt! # uint256
  _connectorBalance: BigInt! # uint256
  _connectorWeight: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
This entity stores one Users history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory @entity {
  """
  ID is userAddress + smartToken. This is because the liquidity pool address can change but the smartToken address stays constant
  """
  id: ID!
  user: User!
  liquidityPool: LiquidityPool!
  """
  Totals of each underlying asset the user has added and removed over all time. This is useful for the frontend to calculate the User's profit from providing liquidity to the pool.
  """
  totalAsset0LiquidityAdded: BigInt!
  totalAsset0LiquidityRemoved: BigInt!
  totalAsset1LiquidityAdded: BigInt!
  totalAsset1LiquidityRemoved: BigInt!
  liquidityHistory: [LiquidityHistoryItem!] @derivedFrom(field: "userLiquidityHistory")
}

"""
Granular LiquidityAdded and LiquidityRemoved event data
"""
type LiquidityHistoryItem @entity {
  """
  ID is transaction hash + log index
  """
  id: ID!
  user: User!
  userLiquidityHistory: UserLiquidityHistory!
  """
  Type is Added or Removed
  """
  type: String! 
  provider: String! # address
  reserveToken: Token! # address
  amount: BigInt! # uint256
  newBalance: BigInt! # uint256
  newSupply: BigInt! # uint256
  timestamp: BigInt!
  liquidityPool: LiquidityPool!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type Activation @entity {
  id: ID!
  _type: Int! # uint16
  _anchor: Bytes! # address
  _activated: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted. Although this is pretty useful, maybe keep
"""
type Conversion @entity {
  id: ID!
  _fromToken: Token! # address
  _toToken: Token! # address
  _trader: Bytes! # address
  _amount: BigInt! # uint256
  _return: BigInt! # uint256
  _conversionFee: BigInt! # int256
  _protocolFee: BigInt! # int256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  swapTransaction: Swap!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type TokenRateUpdate @entity {
  id: ID!
  _token1: Bytes! # address
  _token2: Bytes! # address
  _rateN: BigInt! # uint256
  _rateD: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type ConversionFeeUpdate @entity {
  id: ID!
  _prevFee: BigInt! # uint32
  _newFee: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type WithdrawFees @entity {
  id: ID!
  sender: Bytes! # address
  receiver: Bytes! # address
  token: Bytes! # address
  protocolFeeAmount: BigInt! # uint256
  wRBTCConverted: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type Approval @entity {
  id: ID!
  owner: Bytes! # address
  spender: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type Transfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow @entity {
  id: ID!
  user: User! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  newPrincipal: BigInt! # uint256
  newCollateral: BigInt! # uint256
  interestRate: BigInt! # uint256
  interestDuration: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit @entity {
  id: ID!
  user: Bytes! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  closer: Bytes! # address
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  repayAmount: BigInt! # uint256
  collateralWithdrawAmount: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap @entity {
  id: ID!
  user: Bytes! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  collateralToken: Bytes! # address
  loanToken: Bytes! # address
  closer: Bytes! # address
  positionCloseSize: BigInt! # uint256
  loanCloseAmount: BigInt! # uint256
  exitPrice: BigInt! # uint256
  currentLeverage: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral @entity {
  id: ID!
  loanId: Loan! # bytes32
  depositAmount: BigInt! # uint256
  rate: BigInt # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type EarnReward @entity {
  id: ID!
  receiver: User! # address
  token: Token! # address
  loanId: Loan! # bytes32
  feeRebatePercent: BigInt! # uint256
  amount: BigInt! # uint256
  basisPoint: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate @entity {
  id: ID!
  user: User! # address
  liquidator: Bytes! # address
  loanId: Loan! # bytes32
  lender: Bytes! # address
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  repayAmount: BigInt! # uint256
  collateralWithdrawAmount: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LoanSwap @entity {
  id: ID!
  loanId: Loan! # bytes32
  sourceToken: Bytes! # address
  destToken: Bytes! # address
  borrower: Bytes! # address
  sourceAmount: BigInt! # uint256
  destAmount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  loanId: Loan! # bytes32
  amount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Lends or Unle and when a loan is rolled over
"""
type PayLendingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  loanId: Loan! # bytes32
  amount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type PayTradingFeeToAffiliate @entity {
  id: ID!
  referrer: Bytes! # address
  trader: Bytes! # address
  token: Bytes! # address
  isHeld: Boolean! # bool
  tradingFeeTokenAmount: BigInt! # uint256
  tokenBonusAmount: BigInt! # uint256
  sovBonusAmount: BigInt! # uint256
  sovBonusAmountPaid: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type PayTradingFeeToAffiliateFail @entity {
  id: ID!
  referrer: Bytes! # address
  trader: Bytes! # address
  token: Bytes! # address
  tradingFeeTokenAmount: BigInt! # uint256
  tokenBonusAmount: BigInt! # uint256
  sovBonusAmount: BigInt! # uint256
  sovBonusAmountTryingToPaid: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type ProtocolModuleContractReplaced @entity {
  id: ID!
  prevModuleContractAddress: Bytes! # address
  newModuleContractAddress: Bytes! # address
  module: Bytes! # bytes32
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetAffiliateFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetAffiliateTradingTokenFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetAffiliatesReferrer @entity {
  id: ID!
  user: Bytes! # address
  referrer: Bytes! # address
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetAffiliatesReferrerFail @entity {
  id: ID!
  user: Bytes! # address
  referrer: Bytes! # address
  alreadySet: Boolean! # bool
  userNotFirstTrade: Boolean! # bool
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetBorrowingFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetFeesController @entity {
  id: ID!
  sender: Bytes! # address
  oldController: Bytes! # address
  newController: Bytes! # address
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetLendingFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetLiquidationIncentivePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetLoanPool @entity {
  id: ID!
  sender: Bytes! # address
  loanPool: Bytes! # address
  underlying: Bytes! # address
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted.
"""
type SetWrbtcToken @entity {
  id: ID!
  sender: Bytes! # address
  oldWethToken: Bytes! # address
  newWethToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}


type Trade @entity {
  id: ID!
  user: User! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  collateralToken: Bytes! # address
  loanToken: Bytes! # address
  positionSize: BigInt! # uint256
  borrowedAmount: BigInt! # uint256
  interestRate: BigInt! # uint256
  settlementDate: BigInt! # uint256
  entryPrice: BigInt! # uint256
  entryLeverage: BigInt! # uint256
  currentLeverage: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Lending Contract events

type WithdrawLendingFees @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type WithdrawTradingFees @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Burn @entity {
  id: ID!
  user: User! # address
  tokenAmount: BigInt! # uint256
  assetAmount: BigInt! # uint256
  loanToken: LoanToken!
  price: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  underlyingAsset: Token!
}

type FlashBorrow @entity {
  id: ID!
  user: User! # address
  target: Bytes! # address
  loanAmount: BigInt! # uint256
  loanToken: LoanToken!
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  underlyingAsset: Token!
}

type Mint @entity {
  id: ID!
  user: User! # address
  tokenAmount: BigInt! # uint256
  assetAmount: BigInt! # uint256
  loanToken: LoanToken!
  price: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LoanToken @entity {
  id: ID! #address
  underlyingAsset: Token!
}

# Vesting Resistry

type VestingContract @entity {
  id: ID! # vesting contract id
  user: User!
  createdAtTimestamp: BigInt!
  cliff: BigInt # uint256
  duration: BigInt # uint256
  startingBalance: BigInt! # uint256
  currentBalance: BigInt!
  type: String! # Team, Non-team, Rewards, Fish
  emittedBy: Bytes!
  createdAtTransaction: Transaction!
  stakeHistory: [TokensStaked!]!
  # sovTransferred: [SOVTransferred!] @derivedFrom(field: "receiver")
}

type SOVTransferred @entity {
  id: ID!
  receiver: VestingContract! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# VestingLogic

type DividendsCollected @entity {
  id: ID!
  caller: Bytes! # address
  loanPoolToken: Bytes! # address
  receiver: User! # address
  maxCheckpoints: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensWithdrawn_Vesting @entity {
  id: ID!
  caller: Bytes! # address
  receiver: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Staking contract

type DelegateStakeChanged @entity {
  id: ID!
  delegate: Bytes! # address
  lockedUntil: BigInt! # uint256
  previousBalance: BigInt! # uint256
  newBalance: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensStaked @entity {
  id: ID!
  user: User
  staker: Bytes! # address
  amount: BigInt! # uint256
  lockedUntil: BigInt! # uint256
  totalStaked: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  isUserStaked: Boolean!
}

type VestingTokensWithdrawn @entity {
  id: ID!
  vesting: VestingContract! # address
  receiver: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# This maps to existing stakeHistory api

type UserStakeHistory @entity {
  id: ID! # id is user
  user: User!
  stakeHistory: [StakeHistoryItem!] @derivedFrom(field: "user")
  totalStaked: BigInt!
  totalWithdrawn: BigInt!
  totalRemaining: BigInt!
}

type StakeHistoryItem @entity {
  id: ID! # transaction hash
  user: UserStakeHistory!
  action: String!
  timestamp: BigInt!
  transaction: Transaction!
  amount: BigInt
  lockedUntil: BigInt
}

# Fee Sharing Proxy and Fees History
type UserRewardsEarnedHistory @entity {
  id: ID! # user
  user: User!
  totalFeesAndRewardsEarned: BigInt!
  availableTradingRewards: BigInt!
  availableRewardSov: BigInt!
  rewardsEarnedHistory: [RewardsEarnedHistoryItem!] @derivedFrom(field: "user")
}

type RewardsEarnedHistoryItem @entity {
  id: ID! # transaction hash
  action: String!
  user: UserRewardsEarnedHistory!
  token: Token
  amount: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
}

type FeeAMMWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  converter: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type FeeWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensTransferred @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type UserFeeWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  receiver: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Locked SOV 

type Deposited @entity {
  id: ID!
  _initiator: Bytes! # address
  _userAddress: Bytes! # address
  _sovAmount: BigInt! # uint256
  _basisPoint: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Mining Proxy

type RewardClaimed @entity {
  id: ID!
  user: Bytes! # address
  poolToken: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Staking Reward

type RewardWithdrawn @entity {
  id: ID!
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# TokenConverted

type TokenConverted @entity {
  id: ID!
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Candlesticks

type CandleSticksFifteenMinute @entity {
  id: ID!  # fromToken + toToken + timestamp
  tradingPair: String!  # baseToken_quoteToken
  open: BigDecimal # opening price
  high: BigDecimal! # high price
  low: BigDecimal! # low price
  close: BigDecimal! # close price
  txCount: BigInt! # number of transactions during period
  totalVolume: BigDecimal! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}


# Governor Contracts
type Proposal @entity {
  id: ID! # contract address + id
  created: Transaction!
  canceled: Transaction
  executed: Transaction
  queued: Transaction
  votesFor: BigInt!
  votesAgainst: BigInt!
  countVotersFor: BigInt!
  countVotersAgainst: BigInt!
  votes: [VoteCast!] @derivedFrom(field: "proposal")
  proposalId: BigInt!
  proposer: Bytes! # address
  targets: [String!]! # address[]
  values: [BigInt!]! # uint256[]
  signatures: [String!]! # string[]
  startBlock: BigInt! # uint256
  endBlock: BigInt! # uint256
  description: String! # string
  timestamp: BigInt!
  emittedBy: Bytes! #address
}

type VoteCast @entity {
  id: ID!
  voter: User! # address
  proposalId: BigInt! # uint256
  proposal: Proposal!
  support: Boolean! # bool
  votes: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}
