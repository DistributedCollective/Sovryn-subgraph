schema {
  query: Query
  subscription: Subscription
}
type BitcoinTransfer {
  id: ID!
  btcAddress: String!
  nonce: Int!
  amountBTC: String!
  feeBTC: String!
  totalAmountBTC: String!
  user: User!
  status: BitcoinTransferStatus!
  bitcoinTxHash: String!
  createdAtTimestamp: Int!
  createdAtBlockNumber: Int!
  createdAtTx: Transaction!
  updatedAtTimestamp: Int!
  updatedAtBlockNumber: Int!
  updatedAtTx: Transaction!
}
type BitcoinTransferBatchSending {
  id: ID!
  bitcoinTxHash: String!
  transferBatchSize: Int!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow {
  id: ID!
  user: User!
  lender: String!
  loanId: Loan!
  loanToken: String!
  collateralToken: String!
  newPrincipal: String!
  newCollateral: String!
  interestRate: String!
  interestDuration: String!
  collateralToLoanRate: String!
  currentMargin: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Cross Chain Bridge
"""
type Bridge {
  """
  Bridge ID - Bridge Contract Address
  """
  id: ID!
  """
  BridgeType - there are currently only two bridges - RSK_BSC and RSK_ETH
  """
  type: BridgeType!
  """
  Prefix - prefix added to sideTokens symbol when created
  """
  prefix: String
  """
  isSuffix - is suffix or prefix
  """
  isSuffix: Boolean
  """
  Federation - the Federation entity associated with this bridge
  """
  federation: Federation!
  """
  isUpgrading - Indicates if the bridge is currently upgrading
  """
  isUpgrading: Boolean!
  """
  isPaused - Indicates if the bridge is currently paused
  """
  isPaused: Boolean!
  """
  Pausers - an array of addresses authorized to pause the bridge
  """
  pausers: [String!]!
  """
  CreatedAtTx - The bridge creation transaction
  """
  createdAtTx: Transaction!
  """
  UpdatedAtTx - The bridge last updated at this transaction
  """
  updatedAtTx: Transaction!
}
type CandleStickDay implements ICandleStick {
  id: ID!
  baseToken: Token
  quoteToken: Token
  open: String
  high: String!
  low: String!
  close: String!
  txCount: Int!
  totalVolume: String!
  periodStartUnix: Int!
}
type CandleStickFifteenMinute implements ICandleStick {
  id: ID!
  baseToken: Token
  quoteToken: Token
  open: String
  high: String!
  low: String!
  close: String!
  txCount: Int!
  totalVolume: String!
  periodStartUnix: Int!
}
type CandleStickFourHour implements ICandleStick {
  id: ID!
  baseToken: Token
  quoteToken: Token
  open: String
  high: String!
  low: String!
  close: String!
  txCount: Int!
  totalVolume: String!
  periodStartUnix: Int!
}
type CandleStickHour implements ICandleStick {
  id: ID!
  baseToken: Token
  quoteToken: Token
  open: String
  high: String!
  low: String!
  close: String!
  txCount: Int!
  totalVolume: String!
  periodStartUnix: Int!
}
type CandleStickMinute implements ICandleStick {
  id: ID!
  baseToken: Token
  quoteToken: Token
  open: String
  high: String!
  low: String!
  close: String!
  txCount: Int!
  totalVolume: String!
  periodStartUnix: Int!
}
"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit {
  id: ID!
  user: String!
  lender: String!
  loanId: Loan!
  closer: String!
  loanToken: String!
  collateralToken: String!
  repayAmount: String!
  collateralWithdrawAmount: String!
  collateralToLoanRate: String!
  currentMargin: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap {
  id: ID!
  user: String!
  lender: String!
  loanId: Loan!
  collateralToken: String!
  loanToken: String!
  closer: String!
  positionCloseSize: String!
  loanCloseAmount: String!
  exitPrice: String!
  """
  Leverage on the smart contract does not count user-provided collateral.
  So, what would on the dapp be a 2x leverage trade would be a 1 here
  """
  currentLeverage: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Granular Conversion events, exactly as they appear on the contracts.
These events are the raw data that the Swap entity and candlestick entities are built from.
"""
type Conversion {
  id: ID!
  _fromToken: Token!
  _toToken: Token!
  _trader: String!
  _amount: String!
  _return: String!
  _conversionFee: String!
  _protocolFee: String!
  timestamp: Int!
  emittedBy: LiquidityPool!
  transaction: Transaction!
  blockNumber: Int!
}
"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry {
  """
  ID is the address of the converter registry contract
  """
  id: ID!
  """
  All the converters (AMM pools) associated with this registry
  """
  converters(skip: Int = 0, first: Int = 100, orderBy: LiquidityPool_orderBy, orderDirection: OrderDirection, where: LiquidityPool_filter): [LiquidityPool!]
  """
  All smart tokens in this registry
  """
  smartTokens(skip: Int = 0, first: Int = 100, orderBy: SmartToken_orderBy, orderDirection: OrderDirection, where: SmartToken_filter): [SmartToken!]
  """
  All ERC20 tokens in this registry
  """
  connectorTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]
  """
  The number of active converters (AMM pools) in this registry
  """
  numConverters: Int!
}
type CrossTransfer {
  """
  Id - the cross transfer Id - for outgoing it is generated from the cross event params for incoming it is coming from the federation events
  """
  id: ID!
  """
  Direction - the direction of the cross transfer (Incoming or Outgoing)
  """
  direction: CrossDirection!
  """
  sourceChain - the source chain - for outgoing it is RSK and for incoming it is BSC/ETH
  """
  sourceChain: BridgeChain!
  """
  DestinationChain - the destination chain - for outgoing it is BSC/ETH and for incoming it is RSK
  """
  destinationChain: BridgeChain!
  """
  Votes - Number of votes cast for this transfer
  """
  votes: Int
  """
  Status - transfer status - Voting, Executed, Revoked
  """
  status: CrossStatus!
  """
  originalTokenAddress - the original token address for the transfer (for outgoing it is just the RSK token address)
  """
  originalTokenAddress: String!
  """
  TokenAddress - the token address for the transfer (only relevant for incoming transfers)
  """
  tokenAddress: String
  """
  Token - the token entity if exist of original token address
  """
  token: Token
  """
  sideToken - the SideToken entity if exist of original token address
  """
  sideToken: SideToken
  """
  Address of the user on RSK chain
  """
  rskUser: User!
  """
  Receiver - The receiver of funds (can be a wallet or contract)
  """
  receiver: String
  """
  Sender - The sender of funds (can be a wallet or contracts)
  """
  sender: String
  """
  Amount - the amount of originalToken transferred across the bridge
  """
  amount: String!
  """
  Symbol - the token symbol
  """
  symbol: String
  """
  SourceChainBlockHash - the source chain block hash of the transfer, for outgoing transfers this is just the RSK block hash
  """
  sourceChainBlockHash: String
  """
  SourceChainTransactionHash - the source chain transaction hash of the transfer, for outgoing transfers this is just the RSK transaction hash
  """
  sourceChainTransactionHash: String
  """
  CreatedAtTx - the transaction at which this transfer was created
  """
  createdAtTx: Transaction!
  """
  CreatedAtTimestamp - the timestamp at which this transfer was created
  """
  createdAtTimestamp: Int!
  """
  updatedAtTx - the transaction at which this transfer was last updated
  """
  updatedAtTx: Transaction!
  """
  updatedAtTimestamp - the timestamp at which this transfer was last updated
  """
  updatedAtTimestamp: Int!
}
type Deposit {
  id: ID!
  to: String!
  amount: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral {
  id: ID!
  loanId: Loan!
  depositAmount: String!
  """
  Rate is sometimes null because this property was not included in older versions of the contract
  """
  rate: String
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type FastBTCBridgeStat {
  id: ID!
  user: User
  totalAmountBTCInitialized: String!
  totalAmountBTCSending: String!
  totalAmountBTCMined: String!
  totalFeesBTC: String!
  totalAmountBTCRefunded: String!
  createdAtTx: Transaction!
  updatedAtTx: Transaction!
}
"""
Federation - the federation entity
"""
type Federation {
  """
  Id - the id of the federation entity is the federation contract address
  """
  id: ID!
  """
  IsActive - is this federation contract active
  """
  isActive: Boolean!
  """
  Bridge - the bridge that is associated with this federation contract
  """
  bridge: Bridge!
  """
  TotalVotes - total votes cast on this federation
  """
  totalVotes: Int!
  """
  TotalExecuted - total transfers executed by this federation
  """
  totalExecuted: Int!
  """
  Members - federators that are members of this federation
  """
  members: [String!]!
  """
  CreatedAtTx - the creation transaction of this federation
  """
  createdAtTx: Transaction!
  """
  UpdatedAtTx - the transaction at which this entity was last updated
  """
  updatedAtTx: Transaction!
}
type FeeSharingTokensTransferred {
  id: ID!
  sender: String!
  token: String!
  amount: String!
}
"""
LendingHistoryItem is one user's history of Lend/UnLend events across all the lending pools
"""
type LendingHistoryItem {
  id: ID!
  lender: User!
  """
  Type is Lend/UnLend
  """
  type: LendingHistoryType!
  """
  The lending pool the user interacted with
  """
  lendingPool: LendingPool!
  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token
  """
  The amount of ERC20 token that was lent/unlent
  """
  amount: String!
  """
  The amount of pool token that was minted or burned
  """
  loanTokenAmount: String!
  timestamp: Int!
  transaction: Transaction!
  emittedBy: String!
  """
  Foreign key to the UserLendingHistory entity (see the docs on this entity for more information)
  """
  userLendingHistory: UserLendingHistory!
}
"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool {
  """
  ID is the contract address of the iToken
  """
  id: ID!
  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
  """
  The total supply of this pool token (not the underlying asset).
  It is incremented on Mint events and decremented on Burn events
  """
  poolTokenBalance: String!
  """
  Balance of the underlying asset (ERC20 token) represented by the total supply of pool tokens
  It is incremented on Mint events and decremented on Burn events.
  WORK-IN-PROGRESS: This is a work-in-progress as it does not properly account for interest payments currently
  """
  assetBalance: String!
  """
  Total asset volume lent over all time
  """
  totalAssetLent: String!
}
"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate {
  id: ID!
  user: User!
  liquidator: String!
  loanId: Loan!
  lender: String!
  loanToken: String!
  collateralToken: String!
  repayAmount: String!
  collateralWithdrawAmount: String!
  collateralToLoanRate: String!
  currentMargin: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type LiquidityHistoryItem {
  """
  ID is transaction hash + log index
  """
  id: ID!
  user: User!
  """
  Foreign key to join this transaction to the parent UserLiquidityHistory entity
  """
  userLiquidityHistory: UserLiquidityHistory!
  """
  Type is either Added or Removed (if a user added or removed liquidity from the pool)
  """
  type: LiquidityHistoryType!
  """
  Provider is either the user, or a contract if the user interacted with a proxy contract
  """
  provider: String!
  """
  The underlying asset (ERC20 token) that was added/removed
  """
  reserveToken: Token!
  """
  The amount that was added/removed
  """
  amount: String!
  """
  New balance of the reserveToken (ERC20 token) on the AMM pool
  """
  newBalance: String!
  """
  New total supply of pool tokens
  """
  newSupply: String!
  timestamp: Int!
  """
  AMM pool that liquidity was provided to
  """
  liquidityPool: LiquidityPool!
  """
  The contract that emitted this event (primarily used for debugging)
  """
  emittedBy: String!
  transaction: Transaction!
}
type LiquidityMiningAllocationPoint {
  id: ID!
  allocationPoint: String!
  """
  The amount of SOV earned per block by all LPs in one pool
  Calculated as (totalRewardPerBlock * allocationPoint) / totalAllocationPoint
  """
  rewardPerBlock: String!
  """
  If this pool token is for an AMM liquidity pool, this is a foreign key to the SmartToken.
  If not, this property is null
  """
  ammPoolToken: SmartToken
  """
  If this pool token is for a lending pool, this is a foreign key to the LendingPool.
  If not, this property is null
  """
  lendingPoolToken: LendingPool
  """
  Unix timestamp for when this pool token was added to the liquidity mining program
  """
  poolTokenAddedTimestamp: Int!
  """
  Unix timestamp for when the allocation point for this pool token last changed
  """
  poolTokenUpdatedTimestamp: Int!
  poolTokenAddedBlock: Int!
  poolTokenUpdatedBlock: Int!
}
"""
This entity has only one instance (id: 0), and holds global variables required for liquidity mining rewards calculations
"""
type LiquidityMiningGlobal {
  id: ID!
  """
  Total available allocation points. This is used to calculated the reward per block for each pool token.
  See the LiquidityMiningAllocationPoint entity for more details.
  """
  totalAllocationPoint: String!
  """
  Total possible SOV per block in the liquidity mining program. Not all of this has to be allocation (eg if totalRewardPerBlock = 1000, that does not mean 1000 SOV are being given to LPs per block)
  This is used to calculated the reward per block for each pool token.
  See the LiquidityMiningAllocationPoint entity for more details.
  """
  totalRewardPerBlock: String!
}
"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool {
  """
  ID is the contract address of the Converter
  """
  id: ID!
  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
  smartToken: SmartToken
  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token
  token1: Token
  """
  The balance for each token on this liquidity pool
  NB: For the V2 pools (USDT, DOC, BPRO), this balance is the staked balance, not the contract balance
  """
  token0Balance: String!
  token1Balance: String!
  connectorTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  poolTokens(skip: Int = 0, first: Int = 100, orderBy: PoolToken_orderBy, orderDirection: OrderDirection, where: PoolToken_filter): [PoolToken!]
  owner: String
  """
  Divide by maxConversionFee to get percentage
  """
  conversionFee: String
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  maxConversionFee: String
  createdAtTimestamp: Int
  createdAtBlockNumber: Int
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
}
"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and sold, but this should be moved to the LiquidityPool
"""
type LiquidityPoolToken {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  token: Token!
  liquidityPool: LiquidityPool!
  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  """
  Total volume of this token bought through this liquidity pool
  """
  volumeBought: String!
  """
  Total volume of this token sold through this liquidity pool
  """
  volumeSold: String!
  """
  Total volume of this token that has been bought or sold through this liquidity pool
  """
  totalVolume: String!
}
"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan {
  id: ID!
  """
  The token the loan was taken out in
  """
  loanToken: Token!
  """
  The token provided as collateral
  """
  collateralToken: Token!
  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!
  """
  Unix timestamp at start of loan
  """
  startTimestamp: Int!
  """
  Unix timestamp at end of loan (null if loan is still open)
  """
  endTimestamp: Int
  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: String!
  """
  The amount borrowed when the loan was opened
  """
  startBorrowedAmount: String!
  """
  The largest amount borrowed in the lifetime of this loan
  """
  maxBorrowedAmount: String!
  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: String!
  """
  Initial size of the position
  """
  startPositionSize: String!
  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: String!
  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: String!
  """
  If a Liquidate, CloseWithSwap, Rollover or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!
  """
  Next date that the loan will be rolled over, interest and trading fee paid, and rollover reward paid
  It is possible for the next rollover to be in the past if the loan has not yet been rolled over by the Sovryn node
  """
  nextRollover: Int
  """
  The user who took out the loan
  """
  user: User!
  """
  Trade (margin trade) transactions associated with this loan
  """
  trade(skip: Int = 0, first: Int = 100, orderBy: Trade_orderBy, orderDirection: OrderDirection, where: Trade_filter): [Trade!]
  """
  Borrow transactions associated with this loan
  """
  borrow(skip: Int = 0, first: Int = 100, orderBy: Borrow_orderBy, orderDirection: OrderDirection, where: Borrow_filter): [Borrow!]
  """
  CloseWithSwap events associated with this loan. Emitted when a user partially or fully closes a margin trade.
  """
  closeWithSwaps(skip: Int = 0, first: Int = 100, orderBy: CloseWithSwap_orderBy, orderDirection: OrderDirection, where: CloseWithSwap_filter): [CloseWithSwap!]
  """
  CloseWithDeposit events associated with this loan. Emitted when a user partially or fully closes a borrow loan.
  """
  closeWithDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]
  """
  Any liquidations that have happened on this loan
  """
  liquidates(skip: Int = 0, first: Int = 100, orderBy: Liquidate_orderBy, orderDirection: OrderDirection, where: Liquidate_filter): [Liquidate!]
  """
  DepositCollateral events associated with this loan, where a user has topped up collateral
  """
  depositCollateral(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    where: DepositCollateral_filter
  ): [DepositCollateral!]
  """
  Rollover events associated with this loan.
  Rollovers are loan maintenance transactions where the next interest payment and fee is paid
  """
  rollovers(skip: Int = 0, first: Int = 100, orderBy: Rollover_orderBy, orderDirection: OrderDirection, where: Rollover_filter): [Rollover!]
  """
  Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token
  """
  totalBought: String!
  """
  Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token
  """
  totalSold: String!
  """
  Average price per token from all loan open events
  Updated on Trade and Borrow events
  This is mainly used as internal storage to calculate PnL
  """
  averageBuyPrice: String!
  """
  Average price per token from all loan close events
  Updated on CloseWithSwap, CloseWithDeposit and Liquidate events
  This is mainly used as internal storage to calculate PnL
  """
  averageSellPrice: String!
  """
  Realized profit and loss. This is updated on every loan closing event - partially or fully closing a loan, or a liquidation.
  Currently, this does not take into account fees paid
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: String!
  """
  Percentage profit or loss relative to collateral
  """
  realizedPnLPercent: String!
}
type MarginOrderCanceled {
  id: ID!
  hash: String!
  trader: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type MarginOrderFilled {
  id: ID!
  hash: String!
  trader: User!
  principal: String!
  collateral: String!
  leverageAmount: String!
  loanTokenAddress: String!
  loanTokenSent: String!
  collateralTokenSent: String!
  collateralTokenAddress: String!
  filledPrice: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type OrderCanceled {
  id: ID!
  hash: String!
  maker: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type OrderCreated {
  id: ID!
  hash: String!
  network: Network!
  """
  This is the User address. This is not a User entity because of the testnet/mainnet issue (see above comment)
  """
  order_maker: String!
  order_fromToken: String!
  order_toToken: String!
  """
  The amountIn is a String (usually 1e18), not a human-readable decimal.
  This is because both orderbooks are on testnet, and so this subgraph cannot access the correct number of token decimals for mainnet tokens
  """
  order_amountIn: String!
  """
  The amountIn is a String (usually 1e18), not a human-readable decimal. (See above for explanation)
  """
  order_amountOutMin: String!
  order_recipient: String!
  """
  Timestamp when the order must be filled by
  """
  order_deadline: String!
  """
  Timestamp when the order was created
  """
  order_created: String!
  """
  The price at which the order should be executed.
  This is a String (usually 1e18), not a human-readable decimal. (See above for explanation)
  """
  limitPrice: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type OrderFilled {
  id: ID!
  hash: String!
  maker: User!
  amountIn: String!
  amountOut: String!
  path: [String!]!
  filledPrice: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type OwnerUpdate {
  id: ID!
  prevOwner: String!
  newOwner: String!
  timestamp: String!
  emittedBy: String!
}
"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee {
  id: ID!
  payer: String!
  token: String!
  loanId: Loan!
  amount: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over
"""
type PayLendingFee {
  id: ID!
  payer: String!
  token: String!
  amount: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee {
  id: ID!
  payer: String!
  token: String!
  loanId: Loan!
  amount: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  liquidityPool: LiquidityPool!
  """
  For V1 pools, there will be 2 underlying assets, however for V2 pools there will be just one
  """
  underlyingAssets(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
}
"""
A Proposal is created each time a SIP (Sovryn Improvement Proposal) is proposed
The Proposal is created, voted on, and then executed if it passes
To see if a Proposal has been executed, see if the executed property is null or if it has a transaction
"""
type Proposal {
  """
  ID is the address of the governor contract that was used to create the proposal, + the id of the proposal
  """
  id: ID!
  """
  Transaction that created the proposal
  """
  created: Transaction!
  """
  If the proposal was canceled, the transaction that canceled it (otherwise null)
  """
  canceled: Transaction
  """
  If the proposal was executed, the transaction that executed it (otherwise null)
  """
  executed: Transaction
  """
  If the proposal was queued, the transaction that queued it (otherwise null)
  """
  queued: Transaction
  """
  Number of votes for the proposal (weighted vote, not number of voters)
  """
  votesFor: String!
  """
  Number of votes against the proposal (weighted vote, not number of voters)
  """
  votesAgainst: String!
  """
  Number of unique wallets that voted for this proposal
  """
  countVotersFor: Int!
  """
  Number of unique wallets that voted against this proposal
  """
  countVotersAgainst: Int!
  """
  Individual vote transactions
  """
  votes(skip: Int = 0, first: Int = 100, orderBy: VoteCast_orderBy, orderDirection: OrderDirection, where: VoteCast_filter): [VoteCast!]
  proposalId: Int!
  """
  Address of the user who created this proposal
  """
  proposer: String!
  """
  Contract or contracts that this proposal targets
  """
  targets: [String!]!
  values: [String!]!
  """
  Function signatures in the targeted contract that would be affected by this proposal passing
  """
  signatures: [String!]!
  """
  Block when voting starts
  """
  startBlock: Int!
  """
  Block when voting ends
  """
  endBlock: Int!
  """
  Brief description of what this SIP is for, sometimes with a link to the github repo and README for this proposal
  """
  description: String!
  """
  Timestamp when this proposal was created. This is also available in the created transaction, but is included here so it is possible to order by timestamp
  """
  timestamp: Int!
  """
  The contract that emitted this event
  """
  emittedBy: String!
}
"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats {
  """
  Only one entity should be created, with ID "0"
  """
  id: ID!
  """
  An array of all tokens in the protocol
  """
  tokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  """
  The token currently used as a proxy for USD/BTC prices
  """
  usdStablecoin: Token!
  """
  Current price of BTC in usdStablecoin
  """
  btcUsdPrice: String!
  """
  Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
  Incremented when a user interacts with any contracts tracked by this subgraph.
  Does not include the Zero, Mynt and Perperpetual Swaps users (unless they have also used the core protocol)
  """
  totalUsers: Int!
  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: String!
  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: String!
  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: String!
  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: String!
  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: String!
  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: String!
  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: String!
  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: String!
  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: String!
  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: String!
  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: String!
  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: String!
  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: String!
  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: String!
  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  currentVoluntarilyStakedSov: String!
  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  currentStakedByVestingSov: String!
}
type Query {
  converterRegistry(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  converterRegistries(
    skip: Int = 0
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    where: ConverterRegistry_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConverterRegistry!]!
  smartToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    where: SmartToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartToken!]!
  tokenSmartToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenSmartToken!]!
  poolToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    where: PoolToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolToken!]!
  swap(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  conversion(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    skip: Int = 0
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    where: Conversion_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Conversion!]!
  liquidityPool(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    where: LiquidityPool_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPool!]!
  liquidityPoolToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolToken!]!
  bridge(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bridge
  bridges(
    skip: Int = 0
    first: Int = 100
    orderBy: Bridge_orderBy
    orderDirection: OrderDirection
    where: Bridge_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bridge!]!
  federation(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Federation
  federations(
    skip: Int = 0
    first: Int = 100
    orderBy: Federation_orderBy
    orderDirection: OrderDirection
    where: Federation_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Federation!]!
  crossTransfer(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrossTransfer
  crossTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: CrossTransfer_orderBy
    orderDirection: OrderDirection
    where: CrossTransfer_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CrossTransfer!]!
  sideToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SideToken
  sideTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: SideToken_orderBy
    orderDirection: OrderDirection
    where: SideToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SideToken!]!
  candleStickMinute(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickMinute
  candleStickMinutes(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickMinute_orderBy
    orderDirection: OrderDirection
    where: CandleStickMinute_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickMinute!]!
  candleStickFifteenMinute(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFifteenMinute
  candleStickFifteenMinutes(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickFifteenMinute_orderBy
    orderDirection: OrderDirection
    where: CandleStickFifteenMinute_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickFifteenMinute!]!
  candleStickHour(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickHour
  candleStickHours(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickHour_orderBy
    orderDirection: OrderDirection
    where: CandleStickHour_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickHour!]!
  candleStickFourHour(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFourHour
  candleStickFourHours(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickFourHour_orderBy
    orderDirection: OrderDirection
    where: CandleStickFourHour_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickFourHour!]!
  candleStickDay(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickDay
  candleStickDays(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickDay_orderBy
    orderDirection: OrderDirection
    where: CandleStickDay_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickDay!]!
  bitcoinTransferBatchSending(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransferBatchSending
  bitcoinTransferBatchSendings(
    skip: Int = 0
    first: Int = 100
    orderBy: BitcoinTransferBatchSending_orderBy
    orderDirection: OrderDirection
    where: BitcoinTransferBatchSending_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BitcoinTransferBatchSending!]!
  bitcoinTransfer(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransfer
  bitcoinTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    where: BitcoinTransfer_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BitcoinTransfer!]!
  fastBTCBridgeStat(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FastBTCBridgeStat
  fastBTCBridgeStats(
    skip: Int = 0
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    where: FastBTCBridgeStat_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FastBTCBridgeStat!]!
  proposal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  voteCast(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    where: VoteCast_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VoteCast!]!
  lendingPool(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    where: LendingPool_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingPool!]!
  userLendingHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLendingHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    where: UserLendingHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLendingHistory!]!
  lendingHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LendingHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingHistoryItem!]!
  userLiquidityHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userLiquidityHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    where: UserLiquidityHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLiquidityHistory!]!
  liquidityHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LiquidityHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityHistoryItem!]!
  loan(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    skip: Int = 0
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    where: Loan_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Loan!]!
  borrow(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    skip: Int = 0
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    where: Borrow_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Borrow!]!
  closeWithDeposit(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    where: CloseWithDeposit_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithDeposit!]!
  closeWithSwap(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    where: CloseWithSwap_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithSwap!]!
  depositCollateral(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    where: DepositCollateral_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DepositCollateral!]!
  liquidate(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    where: Liquidate_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidate!]!
  payBorrowingFee(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    where: PayBorrowingFee_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayBorrowingFee!]!
  payLendingFee(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    where: PayLendingFee_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayLendingFee!]!
  payTradingFee(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    where: PayTradingFee_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayTradingFee!]!
  trade(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  rollover(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rollover
  rollovers(
    skip: Int = 0
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    where: Rollover_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Rollover!]!
  orderCreated(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCreated
  orderCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: OrderCreated_orderBy
    orderDirection: OrderDirection
    where: OrderCreated_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OrderCreated!]!
  protocolStat(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProtocolStats
  protocolStats(
    skip: Int = 0
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    where: ProtocolStats_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProtocolStats!]!
  transaction(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  token(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  ownerUpdate(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerUpdate
  ownerUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnerUpdate_orderBy
    orderDirection: OrderDirection
    where: OwnerUpdate_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnerUpdate!]!
  userRewardsEarnedHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userRewardsEarnedHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    where: UserRewardsEarnedHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserRewardsEarnedHistory!]!
  rewardsEarnedHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    where: RewardsEarnedHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardsEarnedHistoryItem!]!
  liquidityMiningGlobal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningGlobal
  liquidityMiningGlobals(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityMiningGlobal_orderBy
    orderDirection: OrderDirection
    where: LiquidityMiningGlobal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityMiningGlobal!]!
  liquidityMiningAllocationPoint(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningAllocationPoint
  liquidityMiningAllocationPoints(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityMiningAllocationPoint_orderBy
    orderDirection: OrderDirection
    where: LiquidityMiningAllocationPoint_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityMiningAllocationPoint!]!
  deposit(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  marginOrderCanceled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderCanceled
  marginOrderCanceleds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarginOrderCanceled_orderBy
    orderDirection: OrderDirection
    where: MarginOrderCanceled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarginOrderCanceled!]!
  marginOrderFilled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderFilled
  marginOrderFilleds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarginOrderFilled_orderBy
    orderDirection: OrderDirection
    where: MarginOrderFilled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarginOrderFilled!]!
  orderCanceled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCanceled
  orderCanceleds(
    skip: Int = 0
    first: Int = 100
    orderBy: OrderCanceled_orderBy
    orderDirection: OrderDirection
    where: OrderCanceled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OrderCanceled!]!
  orderFilled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderFilled
  orderFilleds(
    skip: Int = 0
    first: Int = 100
    orderBy: OrderFilled_orderBy
    orderDirection: OrderDirection
    where: OrderFilled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OrderFilled!]!
  withdrawal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawal!]!
  tokensStaked(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    where: TokensStaked_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensStaked!]!
  userStakeHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userStakeHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    where: UserStakeHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserStakeHistory!]!
  stakeHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    where: StakeHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeHistoryItem!]!
  feeSharingTokensTransferred(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    where: FeeSharingTokensTransferred_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FeeSharingTokensTransferred!]!
  user(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  userTotal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    skip: Int = 0
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    where: UserTotal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserTotal!]!
  vestingContract(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    where: VestingContract_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingContract!]!
  vestingHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: VestingHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingHistoryItem!]!
  icandleStick(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ICandleStick
  icandleSticks(
    skip: Int = 0
    first: Int = 100
    orderBy: ICandleStick_orderBy
    orderDirection: OrderDirection
    where: ICandleStick_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ICandleStick!]!
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
}
type RewardsEarnedHistoryItem {
  id: ID!
  action: RewardsEarnedAction!
  user: UserRewardsEarnedHistory!
  token: String
  amount: String!
  timestamp: Int!
  transaction: Transaction!
}
"""
Granular event data for the Loan entity. Emitted when a Loan is rolled over.
This is when the next installment of interest is paid from the collateral, and the trading fee is paid
This transaction is initiated by the Sovryn node, which earns a reward for doing this
"""
type Rollover {
  id: ID!
  user: User!
  lender: String!
  loanId: Loan!
  principal: String!
  collateral: String!
  endTimestamp: Int!
  """
  The User running the Sovryn node that made this transaction
  """
  rewardReceiver: User!
  """
  The reward received by the User for performing this function
  """
  reward: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
SideToken entity - for every token that is passed across the bridge and does not exist on sovryn a side token is created
"""
type SideToken {
  """
  Id - the side token is stored twice, once with the original token address as id and another with the side token address
  """
  id: ID!
  """
  OriginalTokenAddress - the original token address of the side token
  """
  originalTokenAddress: String!
  """
  SideTokenAddress - the token address on RSK of the side token
  """
  sideTokenAddress: String!
  """
  newSymbol - the new symbol given to the side token
  """
  newSymbol: String!
  """
  Granularity - this is the ERC777 granularity value for the side token
  """
  granularity: String!
  """
  CreatedAtTx - the creation transaction of the side token
  """
  createdAtTx: Transaction!
  """
  UpdatedAtTx - The side token was last updated at this transaction
  """
  updatedAtTx: Transaction!
}
"""
The smart token represents a single reserve asset on a single pool.
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken {
  """
  ID is smart token contract address
  """
  id: ID!
  """
  Name of the smart token (set on the contract)
  """
  name: String
  """
  Symbol for the smart token asset (set on the contract)
  """
  symbol: String
  """
  Number of decimal places for this token
  """
  decimals: Int
  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String
  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool!
  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]
  """
  The contract/account that owns the SmartToken contract. This will typically be the converter registry
  """
  owner: String!
  """
  The converter registry this smart token belongs to. Can be null if token is removed from th registry
  """
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: Int
  addedToRegistryTransactionHash: String
}
"""
This entity is the granular history of user actions related to voluntary staking
"""
type StakeHistoryItem {
  id: ID!
  user: UserStakeHistory!
  action: StakeHistoryAction!
  timestamp: Int!
  transaction: Transaction!
  amount: String
  token: Token
  lockedUntil: Int
}
type Subscription {
  converterRegistry(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  converterRegistries(
    skip: Int = 0
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    where: ConverterRegistry_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConverterRegistry!]!
  smartToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    where: SmartToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartToken!]!
  tokenSmartToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenSmartToken!]!
  poolToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    where: PoolToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolToken!]!
  swap(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  conversion(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    skip: Int = 0
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    where: Conversion_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Conversion!]!
  liquidityPool(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    where: LiquidityPool_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPool!]!
  liquidityPoolToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolToken!]!
  bridge(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bridge
  bridges(
    skip: Int = 0
    first: Int = 100
    orderBy: Bridge_orderBy
    orderDirection: OrderDirection
    where: Bridge_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bridge!]!
  federation(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Federation
  federations(
    skip: Int = 0
    first: Int = 100
    orderBy: Federation_orderBy
    orderDirection: OrderDirection
    where: Federation_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Federation!]!
  crossTransfer(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrossTransfer
  crossTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: CrossTransfer_orderBy
    orderDirection: OrderDirection
    where: CrossTransfer_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CrossTransfer!]!
  sideToken(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SideToken
  sideTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: SideToken_orderBy
    orderDirection: OrderDirection
    where: SideToken_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SideToken!]!
  candleStickMinute(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickMinute
  candleStickMinutes(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickMinute_orderBy
    orderDirection: OrderDirection
    where: CandleStickMinute_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickMinute!]!
  candleStickFifteenMinute(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFifteenMinute
  candleStickFifteenMinutes(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickFifteenMinute_orderBy
    orderDirection: OrderDirection
    where: CandleStickFifteenMinute_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickFifteenMinute!]!
  candleStickHour(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickHour
  candleStickHours(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickHour_orderBy
    orderDirection: OrderDirection
    where: CandleStickHour_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickHour!]!
  candleStickFourHour(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFourHour
  candleStickFourHours(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickFourHour_orderBy
    orderDirection: OrderDirection
    where: CandleStickFourHour_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickFourHour!]!
  candleStickDay(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickDay
  candleStickDays(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStickDay_orderBy
    orderDirection: OrderDirection
    where: CandleStickDay_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStickDay!]!
  bitcoinTransferBatchSending(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransferBatchSending
  bitcoinTransferBatchSendings(
    skip: Int = 0
    first: Int = 100
    orderBy: BitcoinTransferBatchSending_orderBy
    orderDirection: OrderDirection
    where: BitcoinTransferBatchSending_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BitcoinTransferBatchSending!]!
  bitcoinTransfer(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransfer
  bitcoinTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    where: BitcoinTransfer_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BitcoinTransfer!]!
  fastBTCBridgeStat(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FastBTCBridgeStat
  fastBTCBridgeStats(
    skip: Int = 0
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    where: FastBTCBridgeStat_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FastBTCBridgeStat!]!
  proposal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  voteCast(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    where: VoteCast_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VoteCast!]!
  lendingPool(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    where: LendingPool_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingPool!]!
  userLendingHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLendingHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    where: UserLendingHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLendingHistory!]!
  lendingHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LendingHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingHistoryItem!]!
  userLiquidityHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userLiquidityHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    where: UserLiquidityHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLiquidityHistory!]!
  liquidityHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LiquidityHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityHistoryItem!]!
  loan(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    skip: Int = 0
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    where: Loan_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Loan!]!
  borrow(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    skip: Int = 0
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    where: Borrow_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Borrow!]!
  closeWithDeposit(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    where: CloseWithDeposit_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithDeposit!]!
  closeWithSwap(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    where: CloseWithSwap_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithSwap!]!
  depositCollateral(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    where: DepositCollateral_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DepositCollateral!]!
  liquidate(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    where: Liquidate_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidate!]!
  payBorrowingFee(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    where: PayBorrowingFee_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayBorrowingFee!]!
  payLendingFee(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    where: PayLendingFee_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayLendingFee!]!
  payTradingFee(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    where: PayTradingFee_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayTradingFee!]!
  trade(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  rollover(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rollover
  rollovers(
    skip: Int = 0
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    where: Rollover_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Rollover!]!
  orderCreated(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCreated
  orderCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: OrderCreated_orderBy
    orderDirection: OrderDirection
    where: OrderCreated_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OrderCreated!]!
  protocolStat(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProtocolStats
  protocolStats(
    skip: Int = 0
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    where: ProtocolStats_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProtocolStats!]!
  transaction(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  token(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  ownerUpdate(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerUpdate
  ownerUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnerUpdate_orderBy
    orderDirection: OrderDirection
    where: OwnerUpdate_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnerUpdate!]!
  userRewardsEarnedHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userRewardsEarnedHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    where: UserRewardsEarnedHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserRewardsEarnedHistory!]!
  rewardsEarnedHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    where: RewardsEarnedHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardsEarnedHistoryItem!]!
  liquidityMiningGlobal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningGlobal
  liquidityMiningGlobals(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityMiningGlobal_orderBy
    orderDirection: OrderDirection
    where: LiquidityMiningGlobal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityMiningGlobal!]!
  liquidityMiningAllocationPoint(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningAllocationPoint
  liquidityMiningAllocationPoints(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityMiningAllocationPoint_orderBy
    orderDirection: OrderDirection
    where: LiquidityMiningAllocationPoint_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityMiningAllocationPoint!]!
  deposit(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  marginOrderCanceled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderCanceled
  marginOrderCanceleds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarginOrderCanceled_orderBy
    orderDirection: OrderDirection
    where: MarginOrderCanceled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarginOrderCanceled!]!
  marginOrderFilled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderFilled
  marginOrderFilleds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarginOrderFilled_orderBy
    orderDirection: OrderDirection
    where: MarginOrderFilled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarginOrderFilled!]!
  orderCanceled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCanceled
  orderCanceleds(
    skip: Int = 0
    first: Int = 100
    orderBy: OrderCanceled_orderBy
    orderDirection: OrderDirection
    where: OrderCanceled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OrderCanceled!]!
  orderFilled(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderFilled
  orderFilleds(
    skip: Int = 0
    first: Int = 100
    orderBy: OrderFilled_orderBy
    orderDirection: OrderDirection
    where: OrderFilled_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OrderFilled!]!
  withdrawal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    where: Withdrawal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawal!]!
  tokensStaked(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    where: TokensStaked_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensStaked!]!
  userStakeHistory(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userStakeHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    where: UserStakeHistory_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserStakeHistory!]!
  stakeHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    where: StakeHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeHistoryItem!]!
  feeSharingTokensTransferred(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    where: FeeSharingTokensTransferred_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FeeSharingTokensTransferred!]!
  user(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  userTotal(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    skip: Int = 0
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    where: UserTotal_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserTotal!]!
  vestingContract(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    where: VestingContract_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingContract!]!
  vestingHistoryItem(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: VestingHistoryItem_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingHistoryItem!]!
  icandleStick(
    id: ID!
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ICandleStick
  icandleSticks(
    skip: Int = 0
    first: Int = 100
    orderBy: ICandleStick_orderBy
    orderDirection: OrderDirection
    where: ICandleStick_filter
    "The block at which the query should be executed. Can either be a `{ hash: String }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ICandleStick!]!
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
}
"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap {
  """
  Transaction hash of this swap
  """
  id: ID!
  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!
  """
  Token the user converted
  """
  fromToken: Token!
  """
  Token the user received
  """
  toToken: Token!
  fromAmount: String!
  toAmount: String!
  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: String!
  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null.
  Otherwise, this is the user that initiated the transaction.
  """
  user: User
  """
  Was this swap part of a margin trade?
  """
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  """
  Was this swap a limit order?
  """
  isLimit: Boolean!
  timestamp: Int!
  transaction: Transaction!
}
"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token {
  """
  The ID is the contract address of the token on RSK
  """
  id: ID!
  name: String
  symbol: String
  """
  Number of decimal places used in the smart contract for this token
  """
  decimals: Int
  version: Int
  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]
  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]
  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceBtc: String!
  """
  lastPriceBtc is the last traded price of this token in BTC
  """
  lastPriceBtc: String!
  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceUsd: String!
  """
  lastPriceUsd is the last traded price of this token in USD
  """
  lastPriceUsd: String!
  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: String!
  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: String!
  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: String!
  currentConverterRegistry: ConverterRegistry
  """
  Does this token have an AMM pool with rBTC as the other reserve asset?
  """
  hasBtcPool: Boolean
  """
  Does this token have an AMM pool with the protocol stablecoin as the other reserve asset?
  """
  hasStablecoinPool: Boolean
  """
  CrossTransfers: cross transfers list (currently only relevant to SOV)
  """
  crossTransfers(skip: Int = 0, first: Int = 100, orderBy: CrossTransfer_orderBy, orderDirection: OrderDirection, where: CrossTransfer_filter): [CrossTransfer!]
}
"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken {
  """
  ID is token address + smart token address
  """
  id: ID!
  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
  smartToken: SmartToken!
}
"""
This is an event emitted from the staking contract when tokens are staked, either by a user or by a vesting contract
If tokens are staked by a vesting contract, there may be multiple tokens staked event per transaction (eg if tokensa are vested over 10 months, there would be 10 TokensStaked events each with a different lockedUntil date)
We have improvements planned to better represent staking on our subgraph.
"""
type TokensStaked {
  """
  ID is transaction hash + log index
  """
  id: ID!
  """
  If tokens were staked by a vesting contract, user property will be null
  """
  user: User
  """
  The staker is either a user address or a vesting contract address
  """
  staker: String!
  """
  The amount of SOV staked in this event (as mentioned above, there can be multiple TokensStaked events per transaction)
  """
  amount: String!
  """
  The date when these tokens will unlock
  A user/vesting contract can have multiple stakes with different lockedUntil dates
  """
  lockedUntil: Int!
  """
  The total amount staked for this specific user until this specific lockedUntil date
  """
  totalStaked: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
  """
  If this is false, the tokens were staked by a vesting contract, and not voluntarily by a user
  """
  isUserStaked: Boolean!
}
"""
Granular event data for the Loan entity. Emitted when a user opens a Margin Trade
"""
type Trade {
  id: ID!
  user: User!
  lender: String!
  loanId: Loan!
  collateralToken: Token!
  loanToken: Token!
  positionSize: String!
  borrowedAmount: String!
  interestRate: String!
  settlementDate: Int!
  entryPrice: String!
  entryLeverage: String!
  currentLeverage: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
Transaction data, including hash and timestamp
"""
type Transaction {
  """
  ID is transaction hash
  """
  id: ID!
  blockNumber: Int!
  """
  The timestamp the transaction was confirmed
  """
  timestamp: Int!
  gasPrice: String!
  """
  The index of this transaction within the block
  """
  index: Int!
  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: User!
  """
  The contract the user interacted with
  """
  to: String
  value: String!
  gasLimit: String!
}
"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User {
  """
  ID is user wallet address
  """
  id: ID!
  """
  Timestamp of User's first interaction with the protocol (first transaction)
  """
  createdAtTimestamp: Int!
  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps(skip: Int = 0, first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, where: Swap_filter): [Swap!]
  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]
  """
  An array of margin trade Trade events
  """
  trades(skip: Int = 0, first: Int = 100, orderBy: Trade_orderBy, orderDirection: OrderDirection, where: Trade_filter): [Trade!]
  """
  An array of Borrow events
  """
  borrows(skip: Int = 0, first: Int = 100, orderBy: Borrow_orderBy, orderDirection: OrderDirection, where: Borrow_filter): [Borrow!]
  """
  An array of Liquidation events linked to this user
  """
  liquidations(skip: Int = 0, first: Int = 100, orderBy: Liquidate_orderBy, orderDirection: OrderDirection, where: Liquidate_filter): [Liquidate!]
  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans(skip: Int = 0, first: Int = 100, orderBy: Loan_orderBy, orderDirection: OrderDirection, where: Loan_filter): [Loan!]
  """
  The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events.
  """
  lendingHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]
  """
  The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]
  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]
  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    where: VestingContract_filter
  ): [VestingContract!]
  """
  Voting history of User
  """
  votes(skip: Int = 0, first: Int = 100, orderBy: VoteCast_orderBy, orderDirection: OrderDirection, where: VoteCast_filter): [VoteCast!]
  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotal
  """
  FastBTCBridge transfers from BTC to RSK
  """
  bitcoinTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    where: BitcoinTransfer_filter
  ): [BitcoinTransfer!]
  fastBTCBridgeStats(
    skip: Int = 0
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    where: FastBTCBridgeStat_filter
  ): [FastBTCBridgeStat!]
  """
  EVM Bridge transfers
  """
  crossChainTransfer(
    skip: Int = 0
    first: Int = 100
    orderBy: CrossTransfer_orderBy
    orderDirection: OrderDirection
    where: CrossTransfer_filter
  ): [CrossTransfer!]
  """
  Transactions initiated by this user
  """
  transactions(skip: Int = 0, first: Int = 100, orderBy: Transaction_orderBy, orderDirection: OrderDirection, where: Transaction_filter): [Transaction!]
}
"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!
  user: User!
  lendingPool: LendingPool!
  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]
  """
  Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: String!
  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: String!
}
"""
This entity stores one User's history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory {
  """
  The ID is userAddress + '-' + smartToken
  Liquidity Pool address is not used here because when a liquidity pool is updated the address changes, but the smart token address remains the same.
  """
  id: ID!
  user: User!
  """
  This is the pool token (sometimes called smart token), not the liquidity pool address
  """
  poolToken: PoolToken!
  """
  Asset0 is defined on the LiquidityPool.
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset0LiquidityAdded: String!
  totalAsset0LiquidityRemoved: String!
  """
  Asset1 is defined on the LiquidityPool
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset1LiquidityAdded: String!
  totalAsset1LiquidityRemoved: String!
  """
  Granular transaction history for transactions adding or removing liquidity from an AMM pool
  """
  liquidityHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]
}
"""
This entity contains the history, fees and totals regarding one users' SOV rewards
"""
type UserRewardsEarnedHistory {
  id: ID!
  user: User!
  """
  This is the total of all EarnReward and RewardClaimed events
  """
  totalFeesAndRewardsEarned: String!
  """
  SOV rewards earned from margin trading, but not yet claimed and vested
  Incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract
  """
  availableTradingRewards: String!
  """
  Sum of all SOV rewards earned from margin trading.
  Incremented by EarnReward events
  """
  totalTradingRewards: String!
  """
  The total liquidity mining rewards the user has claimed, earned from the lending pools.
  Incremented by RewardClaimed, where poolToken is a lending pool token
  """
  totalLendingRewards: String!
  """
  The total liquidity mining rewards the user has claimed, earned from the amm pools.
  Incremented by RewardClaimed, where poolToken is an amm pool token
  """
  totalLiquidityRewards: String!
  """
  Total liquid SOV rewards the user has earned through staking.
  Incremented by RewardWithdrawn
  """
  totalStakingRewards: String!
  """
  The total protocol fees this user has earned and withdrawn, quoted in RBTC.
  Fees can be paid out in different tokens (usually RBTC and SOV).
  This is the total amount, converted to RBTC using the rate at the time of transaction.
  Incremented by UserFeeWithdrawn
  """
  totalFeeWithdrawn: String!
  """
  Granular events for transaction where a reward is earned
  """
  rewardsEarnedHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]
}
"""
This entity holds the voluntary staking history (ie not staking by a vesting contract) of one user
"""
type UserStakeHistory {
  """
  ID is the user address
  """
  id: ID!
  user: User!
  """
  Granular history of the user's voluntary staking activity
  """
  stakeHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]
  """
  totalStaked is the total amount the user has EVER staked (over all time).
  Eg if they stake 10 SOV and then withdraw it and stake it again, totalStaked is 20 SOV
  """
  totalStaked: String!
  """
  totalWithdrawn is the total amount the user has ever withdrawn from voluntary staking (over all time)
  """
  totalWithdrawn: String!
  """
  totalRemaining is the amount the user currently has staked.
  It should be the same as the result of calling the balanceOf(USER_ADDRESS) method on the staking contract.
  """
  totalRemaining: String!
}
"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotal {
  id: ID!
  user: User!
  totalMarginTradeVolumeUsd: String!
  totalCloseWithSwapVolumeUsd: String!
  totalDepositCollateralVolumeUsd: String!
  totalLiquidateVolumeUsd: String!
  totalAmmVolumeUsd: String!
  totalAmmLpFeesUsd: String!
  totalAmmStakerFeesUsd: String!
  totalTradingFeesUsd: String!
  totalLendingFeesUsd: String!
  totalBorrowingFeesUsd: String!
  totalLendVolumeUsd: String!
  totalUnlendVolumeUsd: String!
  totalBorrowVolumeUsd: String!
  totalCloseWithDepositVolumeUsd: String!
}
"""
This entity represents one vesting contract
A User can have multiple vesting contracts
"""
type VestingContract {
  """
  ID is the vesting contract address
  """
  id: ID!
  """
  The owner of the vesting contract
  """
  user: User!
  """
  Date that the vesting contract was created
  """
  createdAtTimestamp: Int!
  """
  The cliff is the period (in seconds) until the first tokens become liquid on this contract
  """
  cliff: Int
  """
  The total duration of the vesting contract, including the cliff, in seconds.
  For example, a 9 month vesting contract with a 1 month cliff would have a duration of 26280000 (10 months in seconds)
  """
  duration: Int
  """
  The initial balance when this contract was created. This is often 0, as tokens can be added to the contract after contract creation
  """
  startingBalance: String!
  """
  Current balance of tokens on the contract, including locked and liquid tokens that have not been withdrawn.
  Incremented on TokensStaked actions, decremented on TokensWithdrawn actions
  """
  currentBalance: String!
  """
  Type of contract (see VestingContractType docs for more details)
  """
  type: VestingContractType!
  emittedBy: String!
  createdAtTransaction: Transaction!
  """
  A granular history of every action involving this vesting contract
  """
  stakeHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]
}
"""
Granular data for each vesting contract, and any actions involving that contract
"""
type VestingHistoryItem {
  """
  ID is transaction hash + "-" + log index
  For TokensStaked actions, there can be multiple actions per transactions, and each will create a new entity
  """
  id: ID!
  action: VestingHistoryItemAction!
  """
  The staker here will always be the vesting contract
  """
  staker: VestingContract!
  """
  Amount being staked
  """
  amount: String!
  """
  The date when the tokens become unlocked
  """
  lockedUntil: Int!
  """
  Total number of tokens staked until this lockedUntil date
  """
  totalStaked: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
"""
This is the event emitted when a user votes for or against a proposed SIP
"""
type VoteCast {
  """
  ID is transaction hash + log index
  """
  id: ID!
  voter: User!
  """
  The ID of the proposal
  """
  proposalId: Int!
  """
  The ID of the Proposal entity that this vote is for/against
  """
  proposal: Proposal!
  """
  True if the vote is for the proposal, False if it is against
  """
  support: Boolean!
  """
  The number of votes the user cast (the voting power of that user)
  """
  votes: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type Withdrawal {
  id: ID!
  receiver: String!
  amount: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}
type _Block_ {
  "The hash of the block"
  hash: String
  "The block number"
  number: Int!
}
"The type for the top-level _meta field"
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!
  "The deployment ID"
  deployment: String!
  "If `true`, the subgraph encountered indexing errors at some past block"
  hasIndexingErrors: Boolean!
}
"""
Candlesticks are for presentational purposes on the dapp. This entity supports the candlestick trading data on the trading view charts.
Trading data is available for the following pairs:
1. All tokens to RBTC
2. All tokens to current usdStablecoin (see ProtocolStats entity for more information)
There is not candlestick data for other trading pairs as this would cause the amount of data stored to increase exponentially
"""
interface ICandleStick {
  """
  The ID is fromToken + toToken + timestamp
  toToken will be either RBTC or XUSD
  """
  id: ID!
  """
  Eg in the pair SOV-XUSD, the base token is SOV and the quote token is XUSD
  Prices shown are the price of the base token in the quote token (eg price of SOV in XUSD)
  """
  baseToken: Token
  quoteToken: Token
  open: String
  high: String!
  low: String!
  close: String!
  txCount: Int!
  """
  The volume of the base token that has been bought and sold in this time period
  """
  totalVolume: String!
  """
  Unix timestamp for the candlestick start time
  """
  periodStartUnix: Int!
}
enum BitcoinTransferBatchSending_orderBy {
  id
  bitcoinTxHash
  transferBatchSize
  timestamp
  emittedBy
  transaction
}
enum BitcoinTransferStatus {
  """
  the transfer slot has not been initialized
  """
  NOT_APPLICABLE
  """
  the transfer was initiated
  """
  NEW
  """
  the federators have approved this transfer as part of a transfer batch
  """
  SENDING
  """
  the transfer was confirmedly mined in Bitcoin blockchain
  """
  MINED
  """
  the transfer was refunded
  """
  REFUNDED
  """
  the transfer was reclaimed by the user
  """
  RECLAIMED
}
enum BitcoinTransfer_orderBy {
  id
  btcAddress
  nonce
  amountBTC
  feeBTC
  totalAmountBTC
  user
  status
  bitcoinTxHash
  createdAtTimestamp
  createdAtBlockNumber
  createdAtTx
  updatedAtTimestamp
  updatedAtBlockNumber
  updatedAtTx
}
enum Borrow_orderBy {
  id
  user
  lender
  loanId
  loanToken
  collateralToken
  newPrincipal
  newCollateral
  interestRate
  interestDuration
  collateralToLoanRate
  currentMargin
  timestamp
  emittedBy
  transaction
}
enum BridgeChain {
  RSK
  ETH
  BSC
}
"""
BridgeType - only 2 bridges at the moment - RSK <-> BSC and RSK <-> ETH
"""
enum BridgeType {
  RSK_BSC
  RSK_ETH
}
enum Bridge_orderBy {
  id
  type
  prefix
  isSuffix
  federation
  isUpgrading
  isPaused
  pausers
  createdAtTx
  updatedAtTx
}
enum CandleStickDay_orderBy {
  id
  baseToken
  quoteToken
  open
  high
  low
  close
  txCount
  totalVolume
  periodStartUnix
}
enum CandleStickFifteenMinute_orderBy {
  id
  baseToken
  quoteToken
  open
  high
  low
  close
  txCount
  totalVolume
  periodStartUnix
}
enum CandleStickFourHour_orderBy {
  id
  baseToken
  quoteToken
  open
  high
  low
  close
  txCount
  totalVolume
  periodStartUnix
}
enum CandleStickHour_orderBy {
  id
  baseToken
  quoteToken
  open
  high
  low
  close
  txCount
  totalVolume
  periodStartUnix
}
enum CandleStickMinute_orderBy {
  id
  baseToken
  quoteToken
  open
  high
  low
  close
  txCount
  totalVolume
  periodStartUnix
}
enum CandleSticksInterval {
  MinuteInterval
  FifteenMinutesInterval
  HourInterval
  FourHourInterval
  DayInterval
}
enum CloseWithDeposit_orderBy {
  id
  user
  lender
  loanId
  closer
  loanToken
  collateralToken
  repayAmount
  collateralWithdrawAmount
  collateralToLoanRate
  currentMargin
  timestamp
  emittedBy
  transaction
}
enum CloseWithSwap_orderBy {
  id
  user
  lender
  loanId
  collateralToken
  loanToken
  closer
  positionCloseSize
  loanCloseAmount
  exitPrice
  currentLeverage
  timestamp
  emittedBy
  transaction
}
enum Conversion_orderBy {
  id
  _fromToken
  _toToken
  _trader
  _amount
  _return
  _conversionFee
  _protocolFee
  timestamp
  emittedBy
  transaction
  blockNumber
}
enum ConverterRegistry_orderBy {
  id
  converters
  smartTokens
  connectorTokens
  numConverters
}
enum CrossDirection {
  Incoming
  Outgoing
}
enum CrossStatus {
  Voting
  Executed
  Revoked
}
enum CrossTransfer_orderBy {
  id
  direction
  sourceChain
  destinationChain
  votes
  status
  originalTokenAddress
  tokenAddress
  token
  sideToken
  rskUser
  receiver
  sender
  amount
  symbol
  sourceChainBlockHash
  sourceChainTransactionHash
  createdAtTx
  createdAtTimestamp
  updatedAtTx
  updatedAtTimestamp
}
enum DepositCollateral_orderBy {
  id
  loanId
  depositAmount
  rate
  timestamp
  emittedBy
  transaction
}
enum Deposit_orderBy {
  id
  to
  amount
  timestamp
  emittedBy
  transaction
}
enum FastBTCBridgeStat_orderBy {
  id
  user
  totalAmountBTCInitialized
  totalAmountBTCSending
  totalAmountBTCMined
  totalFeesBTC
  totalAmountBTCRefunded
  createdAtTx
  updatedAtTx
}
enum Federation_orderBy {
  id
  isActive
  bridge
  totalVotes
  totalExecuted
  members
  createdAtTx
  updatedAtTx
}
enum FeeSharingTokensTransferred_orderBy {
  id
  sender
  token
  amount
}
enum ICandleStick_orderBy {
  id
  baseToken
  quoteToken
  open
  high
  low
  close
  txCount
  totalVolume
  periodStartUnix
}
enum LendingHistoryItem_orderBy {
  id
  lender
  type
  lendingPool
  asset
  amount
  loanTokenAmount
  timestamp
  transaction
  emittedBy
  userLendingHistory
}
enum LendingHistoryType {
  """
  Lend is equivalent to a Mint event
  """
  Lend
  """
  UnLend is equivalent to a Burn event
  """
  UnLend
}
enum LendingPool_orderBy {
  id
  underlyingAsset
  poolTokenBalance
  assetBalance
  totalAssetLent
}
enum Liquidate_orderBy {
  id
  user
  liquidator
  loanId
  lender
  loanToken
  collateralToken
  repayAmount
  collateralWithdrawAmount
  collateralToLoanRate
  currentMargin
  timestamp
  emittedBy
  transaction
}
enum LiquidityHistoryItem_orderBy {
  id
  user
  userLiquidityHistory
  type
  provider
  reserveToken
  amount
  newBalance
  newSupply
  timestamp
  liquidityPool
  emittedBy
  transaction
}
enum LiquidityHistoryType {
  Added
  Removed
}
enum LiquidityMiningAllocationPoint_orderBy {
  id
  allocationPoint
  rewardPerBlock
  ammPoolToken
  lendingPoolToken
  poolTokenAddedTimestamp
  poolTokenUpdatedTimestamp
  poolTokenAddedBlock
  poolTokenUpdatedBlock
}
enum LiquidityMiningGlobal_orderBy {
  id
  totalAllocationPoint
  totalRewardPerBlock
}
enum LiquidityPoolToken_orderBy {
  id
  token
  liquidityPool
  poolToken
  volumeBought
  volumeSold
  totalVolume
}
enum LiquidityPool_orderBy {
  id
  type
  version
  smartToken
  token0
  token1
  token0Balance
  token1Balance
  connectorTokens
  poolTokens
  owner
  conversionFee
  activated
  maxConversionFee
  createdAtTimestamp
  createdAtBlockNumber
  createdAtTransaction
  currentConverterRegistry
}
enum LoanType {
  """
  Trade is a loan originating from a margin trade
  """
  Trade
  """
  Borrow is a loan originating from a user simply borrowing funds
  """
  Borrow
}
enum Loan_orderBy {
  id
  loanToken
  collateralToken
  type
  startTimestamp
  endTimestamp
  borrowedAmount
  startBorrowedAmount
  maxBorrowedAmount
  positionSize
  startPositionSize
  maximumPositionSize
  startRate
  isOpen
  nextRollover
  user
  trade
  borrow
  closeWithSwaps
  closeWithDeposits
  liquidates
  depositCollateral
  rollovers
  totalBought
  totalSold
  averageBuyPrice
  averageSellPrice
  realizedPnL
  realizedPnLPercent
}
enum MarginOrderCanceled_orderBy {
  id
  hash
  trader
  timestamp
  emittedBy
  transaction
}
enum MarginOrderFilled_orderBy {
  id
  hash
  trader
  principal
  collateral
  leverageAmount
  loanTokenAddress
  loanTokenSent
  collateralTokenSent
  collateralTokenAddress
  filledPrice
  timestamp
  emittedBy
  transaction
}
enum Network {
  Mainnet
  Testnet
}
enum OrderCanceled_orderBy {
  id
  hash
  maker
  timestamp
  emittedBy
  transaction
}
enum OrderCreated_orderBy {
  id
  hash
  network
  order_maker
  order_fromToken
  order_toToken
  order_amountIn
  order_amountOutMin
  order_recipient
  order_deadline
  order_created
  limitPrice
  timestamp
  emittedBy
  transaction
}
enum OrderDirection {
  asc
  desc
}
enum OrderFilled_orderBy {
  id
  hash
  maker
  amountIn
  amountOut
  path
  filledPrice
  timestamp
  emittedBy
  transaction
}
enum OwnerUpdate_orderBy {
  id
  prevOwner
  newOwner
  timestamp
  emittedBy
}
enum PayBorrowingFee_orderBy {
  id
  payer
  token
  loanId
  amount
  timestamp
  emittedBy
  transaction
}
enum PayLendingFee_orderBy {
  id
  payer
  token
  amount
  timestamp
  emittedBy
  transaction
}
enum PayTradingFee_orderBy {
  id
  payer
  token
  loanId
  amount
  timestamp
  emittedBy
  transaction
}
enum PoolToken_orderBy {
  id
  name
  symbol
  decimals
  liquidityPool
  underlyingAssets
}
enum Proposal_orderBy {
  id
  created
  canceled
  executed
  queued
  votesFor
  votesAgainst
  countVotersFor
  countVotersAgainst
  votes
  proposalId
  proposer
  targets
  values
  signatures
  startBlock
  endBlock
  description
  timestamp
  emittedBy
}
enum ProtocolStats_orderBy {
  id
  tokens
  usdStablecoin
  btcUsdPrice
  totalUsers
  totalMarginTradeVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLiquidateVolumeUsd
  totalAmmVolumeUsd
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalTradingFeesUsd
  totalLendingFeesUsd
  totalBorrowingFeesUsd
  totalLendVolumeUsd
  totalUnlendVolumeUsd
  totalBorrowVolumeUsd
  totalCloseWithDepositVolumeUsd
  currentVoluntarilyStakedSov
  currentStakedByVestingSov
}
enum RewardsEarnedAction {
  """
  When a SOV Staker withdraws their liquid SOV reward for staking
  """
  StakingRewardWithdrawn
  """
  SOV reward earned when a user margin trades or one of their trades is rolled over.
  The reward is a percentage of the trading fee, paid in SOV.
  """
  EarnReward
  """
  When a user claims a liquidity mining reward
  """
  RewardClaimed
  """
  When SOV is staked by a Rewards vesting contract (eg after it has been claimed by the user)
  """
  RewardSovStaked
  """
  When an SOV Staker withdraws their share of the fees earned by the Protocol
  """
  UserFeeWithdrawn
}
enum RewardsEarnedHistoryItem_orderBy {
  id
  action
  user
  token
  amount
  timestamp
  transaction
}
enum Rollover_orderBy {
  id
  user
  lender
  loanId
  principal
  collateral
  endTimestamp
  rewardReceiver
  reward
  timestamp
  emittedBy
  transaction
}
enum SideToken_orderBy {
  id
  originalTokenAddress
  sideTokenAddress
  newSymbol
  granularity
  createdAtTx
  updatedAtTx
}
enum SmartToken_orderBy {
  id
  name
  symbol
  decimals
  smartTokenType
  liquidityPool
  connectorTokens
  owner
  currentConverterRegistry
  addedToRegistryBlockNumber
  addedToRegistryTransactionHash
}
enum StakeHistoryAction {
  """
  Voluntarily staking SOV (ie not staked through a vesting contract)
  """
  Stake
  """
  Increasing the amount of an existing stake. The lockedUntil date of this stake remains the same, but amount increases.
  """
  IncreaseStake
  """
  Extending an existing stake. The amount of the stake remains the same, but the lockedUntil date increases.
  """
  ExtendStake
  """
  When a user delegates voting power to another user. This can also be for voting power that the user has through a vesting contract.
  """
  Delegate
  """
  Unstake is early unstaking, when a user withdraws staked SOV before the lockedUntil date and incurs a slashing penalty.
  """
  Unstake
  """
  WithdrawStaked is when a user withdraws SOV from the staking contract after the unlock date, when the funds are no longer staked or locked
  """
  WithdrawStaked
  """
  When a user withdraws their share of the Protocol fees that is shared amongst stakers
  """
  FeeWithdrawn
}
enum StakeHistoryItem_orderBy {
  id
  user
  action
  timestamp
  transaction
  amount
  token
  lockedUntil
}
enum Swap_orderBy {
  id
  numConversions
  fromToken
  toToken
  fromAmount
  toAmount
  rate
  user
  isMarginTrade
  isBorrow
  isLimit
  timestamp
  transaction
}
enum TokenSmartToken_orderBy {
  id
  token
  smartToken
}
enum Token_orderBy {
  id
  name
  symbol
  decimals
  version
  liquidityPools
  smartTokens
  prevPriceBtc
  lastPriceBtc
  prevPriceUsd
  lastPriceUsd
  btcVolume
  usdVolume
  tokenVolume
  currentConverterRegistry
  hasBtcPool
  hasStablecoinPool
  crossTransfers
}
enum TokensStaked_orderBy {
  id
  user
  staker
  amount
  lockedUntil
  totalStaked
  timestamp
  emittedBy
  transaction
  isUserStaked
}
enum Trade_orderBy {
  id
  user
  lender
  loanId
  collateralToken
  loanToken
  positionSize
  borrowedAmount
  interestRate
  settlementDate
  entryPrice
  entryLeverage
  currentLeverage
  timestamp
  emittedBy
  transaction
}
enum Transaction_orderBy {
  id
  blockNumber
  timestamp
  gasPrice
  index
  from
  to
  value
  gasLimit
}
enum UserLendingHistory_orderBy {
  id
  user
  lendingPool
  lendingHistory
  totalLendVolume
  totalUnlendVolume
}
enum UserLiquidityHistory_orderBy {
  id
  user
  poolToken
  totalAsset0LiquidityAdded
  totalAsset0LiquidityRemoved
  totalAsset1LiquidityAdded
  totalAsset1LiquidityRemoved
  liquidityHistory
}
enum UserRewardsEarnedHistory_orderBy {
  id
  user
  totalFeesAndRewardsEarned
  availableTradingRewards
  totalTradingRewards
  totalLendingRewards
  totalLiquidityRewards
  totalStakingRewards
  totalFeeWithdrawn
  rewardsEarnedHistory
}
enum UserStakeHistory_orderBy {
  id
  user
  stakeHistory
  totalStaked
  totalWithdrawn
  totalRemaining
}
enum UserTotal_orderBy {
  id
  user
  totalMarginTradeVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLiquidateVolumeUsd
  totalAmmVolumeUsd
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalTradingFeesUsd
  totalLendingFeesUsd
  totalBorrowingFeesUsd
  totalLendVolumeUsd
  totalUnlendVolumeUsd
  totalBorrowVolumeUsd
  totalCloseWithDepositVolumeUsd
}
enum User_orderBy {
  id
  createdAtTimestamp
  swaps
  liquidityHistory
  trades
  borrows
  liquidations
  loans
  lendingHistory
  stakeHistory
  rewardsEarnedHistory
  vestingContracts
  votes
  userTotals
  bitcoinTransfers
  fastBTCBridgeStats
  crossChainTransfer
  transactions
}
enum VestingContractType {
  """
  Vesting contracts for investors who participated in the Sovryn Origin sale
  """
  Origins
  """
  Vesting contracts for investors who participated in the Sovryn Genesis sale
  """
  Genesis
  """
  FISH (Babelfish governance token) vesting contracts
  """
  Fish
  """
  Babelfish team vesting contracts
  """
  FishTeam
  """
  Sovryn team vesting contracts
  """
  Team
  """
  Vesting contracts for vested rewards
  """
  Rewards
  """
  Vesting contracts for strategic investors with a four-year lockup
  """
  FourYearVesting
  """
  Vesting contracts for early strategic investors
  """
  Strategic
}
enum VestingContract_orderBy {
  id
  user
  createdAtTimestamp
  cliff
  duration
  startingBalance
  currentBalance
  type
  emittedBy
  createdAtTransaction
  stakeHistory
}
enum VestingHistoryItemAction {
  """
  Tokens are staked by the Vesting contract. This happens when the Vesting contract receives funds.
  """
  TokensStaked
  """
  This is only relevant to Team tokens. For Team contracts, a vesting contract can be revoked by governance if a team member leaves the project.
  If this happens, all tokens still locked are returned to the exchequer.
  This is ONLY possible with Team or FishTeam vesting contracts.
  """
  TeamTokensRevoked
  """
  When a user withdraws unlocked tokens from the vesting contract
  """
  TokensWithdrawn
}
enum VestingHistoryItem_orderBy {
  id
  action
  staker
  amount
  lockedUntil
  totalStaked
  timestamp
  emittedBy
  transaction
}
enum VoteCast_orderBy {
  id
  voter
  proposalId
  proposal
  support
  votes
  timestamp
  emittedBy
  transaction
}
enum Withdrawal_orderBy {
  id
  receiver
  amount
  timestamp
  emittedBy
  transaction
}
enum _SubgraphErrorPolicy_ {
  "Data will be returned even if the subgraph has indexing errors"
  allow
  "If the subgraph has indexing errors, data will be omitted. The default."
  deny
}
input BitcoinTransferBatchSending_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  bitcoinTxHash: String
  bitcoinTxHash_not: String
  bitcoinTxHash_in: [String!]
  bitcoinTxHash_not_in: [String!]
  bitcoinTxHash_contains: String
  bitcoinTxHash_not_contains: String
  transferBatchSize: Int
  transferBatchSize_not: Int
  transferBatchSize_gt: Int
  transferBatchSize_lt: Int
  transferBatchSize_gte: Int
  transferBatchSize_lte: Int
  transferBatchSize_in: [Int!]
  transferBatchSize_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input BitcoinTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  btcAddress: String
  btcAddress_not: String
  btcAddress_gt: String
  btcAddress_lt: String
  btcAddress_gte: String
  btcAddress_lte: String
  btcAddress_in: [String!]
  btcAddress_not_in: [String!]
  btcAddress_contains: String
  btcAddress_not_contains: String
  btcAddress_starts_with: String
  btcAddress_not_starts_with: String
  btcAddress_ends_with: String
  btcAddress_not_ends_with: String
  nonce: Int
  nonce_not: Int
  nonce_gt: Int
  nonce_lt: Int
  nonce_gte: Int
  nonce_lte: Int
  nonce_in: [Int!]
  nonce_not_in: [Int!]
  amountBTC: String
  amountBTC_not: String
  amountBTC_gt: String
  amountBTC_lt: String
  amountBTC_gte: String
  amountBTC_lte: String
  amountBTC_in: [String!]
  amountBTC_not_in: [String!]
  feeBTC: String
  feeBTC_not: String
  feeBTC_gt: String
  feeBTC_lt: String
  feeBTC_gte: String
  feeBTC_lte: String
  feeBTC_in: [String!]
  feeBTC_not_in: [String!]
  totalAmountBTC: String
  totalAmountBTC_not: String
  totalAmountBTC_gt: String
  totalAmountBTC_lt: String
  totalAmountBTC_gte: String
  totalAmountBTC_lte: String
  totalAmountBTC_in: [String!]
  totalAmountBTC_not_in: [String!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  status: BitcoinTransferStatus
  status_not: BitcoinTransferStatus
  status_in: [BitcoinTransferStatus!]
  status_not_in: [BitcoinTransferStatus!]
  bitcoinTxHash: String
  bitcoinTxHash_not: String
  bitcoinTxHash_in: [String!]
  bitcoinTxHash_not_in: [String!]
  bitcoinTxHash_contains: String
  bitcoinTxHash_not_contains: String
  createdAtTimestamp: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_lt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_not_in: [Int!]
  createdAtBlockNumber: Int
  createdAtBlockNumber_not: Int
  createdAtBlockNumber_gt: Int
  createdAtBlockNumber_lt: Int
  createdAtBlockNumber_gte: Int
  createdAtBlockNumber_lte: Int
  createdAtBlockNumber_in: [Int!]
  createdAtBlockNumber_not_in: [Int!]
  createdAtTx: String
  createdAtTx_not: String
  createdAtTx_gt: String
  createdAtTx_lt: String
  createdAtTx_gte: String
  createdAtTx_lte: String
  createdAtTx_in: [String!]
  createdAtTx_not_in: [String!]
  createdAtTx_contains: String
  createdAtTx_not_contains: String
  createdAtTx_starts_with: String
  createdAtTx_not_starts_with: String
  createdAtTx_ends_with: String
  createdAtTx_not_ends_with: String
  updatedAtTimestamp: Int
  updatedAtTimestamp_not: Int
  updatedAtTimestamp_gt: Int
  updatedAtTimestamp_lt: Int
  updatedAtTimestamp_gte: Int
  updatedAtTimestamp_lte: Int
  updatedAtTimestamp_in: [Int!]
  updatedAtTimestamp_not_in: [Int!]
  updatedAtBlockNumber: Int
  updatedAtBlockNumber_not: Int
  updatedAtBlockNumber_gt: Int
  updatedAtBlockNumber_lt: Int
  updatedAtBlockNumber_gte: Int
  updatedAtBlockNumber_lte: Int
  updatedAtBlockNumber_in: [Int!]
  updatedAtBlockNumber_not_in: [Int!]
  updatedAtTx: String
  updatedAtTx_not: String
  updatedAtTx_gt: String
  updatedAtTx_lt: String
  updatedAtTx_gte: String
  updatedAtTx_lte: String
  updatedAtTx_in: [String!]
  updatedAtTx_not_in: [String!]
  updatedAtTx_contains: String
  updatedAtTx_not_contains: String
  updatedAtTx_starts_with: String
  updatedAtTx_not_starts_with: String
  updatedAtTx_ends_with: String
  updatedAtTx_not_ends_with: String
}
input Block_height {
  hash: String
  number: Int
  number_gte: Int
}
input Borrow_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  lender: String
  lender_not: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  loanToken: String
  loanToken_not: String
  loanToken_in: [String!]
  loanToken_not_in: [String!]
  loanToken_contains: String
  loanToken_not_contains: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_not_contains: String
  newPrincipal: String
  newPrincipal_not: String
  newPrincipal_gt: String
  newPrincipal_lt: String
  newPrincipal_gte: String
  newPrincipal_lte: String
  newPrincipal_in: [String!]
  newPrincipal_not_in: [String!]
  newCollateral: String
  newCollateral_not: String
  newCollateral_gt: String
  newCollateral_lt: String
  newCollateral_gte: String
  newCollateral_lte: String
  newCollateral_in: [String!]
  newCollateral_not_in: [String!]
  interestRate: String
  interestRate_not: String
  interestRate_gt: String
  interestRate_lt: String
  interestRate_gte: String
  interestRate_lte: String
  interestRate_in: [String!]
  interestRate_not_in: [String!]
  interestDuration: String
  interestDuration_not: String
  interestDuration_gt: String
  interestDuration_lt: String
  interestDuration_gte: String
  interestDuration_lte: String
  interestDuration_in: [String!]
  interestDuration_not_in: [String!]
  collateralToLoanRate: String
  collateralToLoanRate_not: String
  collateralToLoanRate_gt: String
  collateralToLoanRate_lt: String
  collateralToLoanRate_gte: String
  collateralToLoanRate_lte: String
  collateralToLoanRate_in: [String!]
  collateralToLoanRate_not_in: [String!]
  currentMargin: String
  currentMargin_not: String
  currentMargin_gt: String
  currentMargin_lt: String
  currentMargin_gte: String
  currentMargin_lte: String
  currentMargin_in: [String!]
  currentMargin_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input Bridge_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: BridgeType
  type_not: BridgeType
  type_in: [BridgeType!]
  type_not_in: [BridgeType!]
  prefix: String
  prefix_not: String
  prefix_gt: String
  prefix_lt: String
  prefix_gte: String
  prefix_lte: String
  prefix_in: [String!]
  prefix_not_in: [String!]
  prefix_contains: String
  prefix_not_contains: String
  prefix_starts_with: String
  prefix_not_starts_with: String
  prefix_ends_with: String
  prefix_not_ends_with: String
  isSuffix: Boolean
  isSuffix_not: Boolean
  isSuffix_in: [Boolean!]
  isSuffix_not_in: [Boolean!]
  federation: String
  federation_not: String
  federation_gt: String
  federation_lt: String
  federation_gte: String
  federation_lte: String
  federation_in: [String!]
  federation_not_in: [String!]
  federation_contains: String
  federation_not_contains: String
  federation_starts_with: String
  federation_not_starts_with: String
  federation_ends_with: String
  federation_not_ends_with: String
  isUpgrading: Boolean
  isUpgrading_not: Boolean
  isUpgrading_in: [Boolean!]
  isUpgrading_not_in: [Boolean!]
  isPaused: Boolean
  isPaused_not: Boolean
  isPaused_in: [Boolean!]
  isPaused_not_in: [Boolean!]
  pausers: [String!]
  pausers_not: [String!]
  pausers_contains: [String!]
  pausers_not_contains: [String!]
  createdAtTx: String
  createdAtTx_not: String
  createdAtTx_gt: String
  createdAtTx_lt: String
  createdAtTx_gte: String
  createdAtTx_lte: String
  createdAtTx_in: [String!]
  createdAtTx_not_in: [String!]
  createdAtTx_contains: String
  createdAtTx_not_contains: String
  createdAtTx_starts_with: String
  createdAtTx_not_starts_with: String
  createdAtTx_ends_with: String
  createdAtTx_not_ends_with: String
  updatedAtTx: String
  updatedAtTx_not: String
  updatedAtTx_gt: String
  updatedAtTx_lt: String
  updatedAtTx_gte: String
  updatedAtTx_lte: String
  updatedAtTx_in: [String!]
  updatedAtTx_not_in: [String!]
  updatedAtTx_contains: String
  updatedAtTx_not_contains: String
  updatedAtTx_starts_with: String
  updatedAtTx_not_starts_with: String
  updatedAtTx_ends_with: String
  updatedAtTx_not_ends_with: String
}
input CandleStickDay_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_not_contains: String
  baseToken_starts_with: String
  baseToken_not_starts_with: String
  baseToken_ends_with: String
  baseToken_not_ends_with: String
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_not_contains: String
  quoteToken_starts_with: String
  quoteToken_not_starts_with: String
  quoteToken_ends_with: String
  quoteToken_not_ends_with: String
  open: String
  open_not: String
  open_gt: String
  open_lt: String
  open_gte: String
  open_lte: String
  open_in: [String!]
  open_not_in: [String!]
  high: String
  high_not: String
  high_gt: String
  high_lt: String
  high_gte: String
  high_lte: String
  high_in: [String!]
  high_not_in: [String!]
  low: String
  low_not: String
  low_gt: String
  low_lt: String
  low_gte: String
  low_lte: String
  low_in: [String!]
  low_not_in: [String!]
  close: String
  close_not: String
  close_gt: String
  close_lt: String
  close_gte: String
  close_lte: String
  close_in: [String!]
  close_not_in: [String!]
  txCount: Int
  txCount_not: Int
  txCount_gt: Int
  txCount_lt: Int
  txCount_gte: Int
  txCount_lte: Int
  txCount_in: [Int!]
  txCount_not_in: [Int!]
  totalVolume: String
  totalVolume_not: String
  totalVolume_gt: String
  totalVolume_lt: String
  totalVolume_gte: String
  totalVolume_lte: String
  totalVolume_in: [String!]
  totalVolume_not_in: [String!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
}
input CandleStickFifteenMinute_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_not_contains: String
  baseToken_starts_with: String
  baseToken_not_starts_with: String
  baseToken_ends_with: String
  baseToken_not_ends_with: String
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_not_contains: String
  quoteToken_starts_with: String
  quoteToken_not_starts_with: String
  quoteToken_ends_with: String
  quoteToken_not_ends_with: String
  open: String
  open_not: String
  open_gt: String
  open_lt: String
  open_gte: String
  open_lte: String
  open_in: [String!]
  open_not_in: [String!]
  high: String
  high_not: String
  high_gt: String
  high_lt: String
  high_gte: String
  high_lte: String
  high_in: [String!]
  high_not_in: [String!]
  low: String
  low_not: String
  low_gt: String
  low_lt: String
  low_gte: String
  low_lte: String
  low_in: [String!]
  low_not_in: [String!]
  close: String
  close_not: String
  close_gt: String
  close_lt: String
  close_gte: String
  close_lte: String
  close_in: [String!]
  close_not_in: [String!]
  txCount: Int
  txCount_not: Int
  txCount_gt: Int
  txCount_lt: Int
  txCount_gte: Int
  txCount_lte: Int
  txCount_in: [Int!]
  txCount_not_in: [Int!]
  totalVolume: String
  totalVolume_not: String
  totalVolume_gt: String
  totalVolume_lt: String
  totalVolume_gte: String
  totalVolume_lte: String
  totalVolume_in: [String!]
  totalVolume_not_in: [String!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
}
input CandleStickFourHour_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_not_contains: String
  baseToken_starts_with: String
  baseToken_not_starts_with: String
  baseToken_ends_with: String
  baseToken_not_ends_with: String
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_not_contains: String
  quoteToken_starts_with: String
  quoteToken_not_starts_with: String
  quoteToken_ends_with: String
  quoteToken_not_ends_with: String
  open: String
  open_not: String
  open_gt: String
  open_lt: String
  open_gte: String
  open_lte: String
  open_in: [String!]
  open_not_in: [String!]
  high: String
  high_not: String
  high_gt: String
  high_lt: String
  high_gte: String
  high_lte: String
  high_in: [String!]
  high_not_in: [String!]
  low: String
  low_not: String
  low_gt: String
  low_lt: String
  low_gte: String
  low_lte: String
  low_in: [String!]
  low_not_in: [String!]
  close: String
  close_not: String
  close_gt: String
  close_lt: String
  close_gte: String
  close_lte: String
  close_in: [String!]
  close_not_in: [String!]
  txCount: Int
  txCount_not: Int
  txCount_gt: Int
  txCount_lt: Int
  txCount_gte: Int
  txCount_lte: Int
  txCount_in: [Int!]
  txCount_not_in: [Int!]
  totalVolume: String
  totalVolume_not: String
  totalVolume_gt: String
  totalVolume_lt: String
  totalVolume_gte: String
  totalVolume_lte: String
  totalVolume_in: [String!]
  totalVolume_not_in: [String!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
}
input CandleStickHour_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_not_contains: String
  baseToken_starts_with: String
  baseToken_not_starts_with: String
  baseToken_ends_with: String
  baseToken_not_ends_with: String
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_not_contains: String
  quoteToken_starts_with: String
  quoteToken_not_starts_with: String
  quoteToken_ends_with: String
  quoteToken_not_ends_with: String
  open: String
  open_not: String
  open_gt: String
  open_lt: String
  open_gte: String
  open_lte: String
  open_in: [String!]
  open_not_in: [String!]
  high: String
  high_not: String
  high_gt: String
  high_lt: String
  high_gte: String
  high_lte: String
  high_in: [String!]
  high_not_in: [String!]
  low: String
  low_not: String
  low_gt: String
  low_lt: String
  low_gte: String
  low_lte: String
  low_in: [String!]
  low_not_in: [String!]
  close: String
  close_not: String
  close_gt: String
  close_lt: String
  close_gte: String
  close_lte: String
  close_in: [String!]
  close_not_in: [String!]
  txCount: Int
  txCount_not: Int
  txCount_gt: Int
  txCount_lt: Int
  txCount_gte: Int
  txCount_lte: Int
  txCount_in: [Int!]
  txCount_not_in: [Int!]
  totalVolume: String
  totalVolume_not: String
  totalVolume_gt: String
  totalVolume_lt: String
  totalVolume_gte: String
  totalVolume_lte: String
  totalVolume_in: [String!]
  totalVolume_not_in: [String!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
}
input CandleStickMinute_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_not_contains: String
  baseToken_starts_with: String
  baseToken_not_starts_with: String
  baseToken_ends_with: String
  baseToken_not_ends_with: String
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_not_contains: String
  quoteToken_starts_with: String
  quoteToken_not_starts_with: String
  quoteToken_ends_with: String
  quoteToken_not_ends_with: String
  open: String
  open_not: String
  open_gt: String
  open_lt: String
  open_gte: String
  open_lte: String
  open_in: [String!]
  open_not_in: [String!]
  high: String
  high_not: String
  high_gt: String
  high_lt: String
  high_gte: String
  high_lte: String
  high_in: [String!]
  high_not_in: [String!]
  low: String
  low_not: String
  low_gt: String
  low_lt: String
  low_gte: String
  low_lte: String
  low_in: [String!]
  low_not_in: [String!]
  close: String
  close_not: String
  close_gt: String
  close_lt: String
  close_gte: String
  close_lte: String
  close_in: [String!]
  close_not_in: [String!]
  txCount: Int
  txCount_not: Int
  txCount_gt: Int
  txCount_lt: Int
  txCount_gte: Int
  txCount_lte: Int
  txCount_in: [Int!]
  txCount_not_in: [Int!]
  totalVolume: String
  totalVolume_not: String
  totalVolume_gt: String
  totalVolume_lt: String
  totalVolume_gte: String
  totalVolume_lte: String
  totalVolume_in: [String!]
  totalVolume_not_in: [String!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
}
input CloseWithDeposit_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  lender: String
  lender_not: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  closer: String
  closer_not: String
  closer_in: [String!]
  closer_not_in: [String!]
  closer_contains: String
  closer_not_contains: String
  loanToken: String
  loanToken_not: String
  loanToken_in: [String!]
  loanToken_not_in: [String!]
  loanToken_contains: String
  loanToken_not_contains: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_not_contains: String
  repayAmount: String
  repayAmount_not: String
  repayAmount_gt: String
  repayAmount_lt: String
  repayAmount_gte: String
  repayAmount_lte: String
  repayAmount_in: [String!]
  repayAmount_not_in: [String!]
  collateralWithdrawAmount: String
  collateralWithdrawAmount_not: String
  collateralWithdrawAmount_gt: String
  collateralWithdrawAmount_lt: String
  collateralWithdrawAmount_gte: String
  collateralWithdrawAmount_lte: String
  collateralWithdrawAmount_in: [String!]
  collateralWithdrawAmount_not_in: [String!]
  collateralToLoanRate: String
  collateralToLoanRate_not: String
  collateralToLoanRate_gt: String
  collateralToLoanRate_lt: String
  collateralToLoanRate_gte: String
  collateralToLoanRate_lte: String
  collateralToLoanRate_in: [String!]
  collateralToLoanRate_not_in: [String!]
  currentMargin: String
  currentMargin_not: String
  currentMargin_gt: String
  currentMargin_lt: String
  currentMargin_gte: String
  currentMargin_lte: String
  currentMargin_in: [String!]
  currentMargin_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input CloseWithSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  lender: String
  lender_not: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_not_contains: String
  loanToken: String
  loanToken_not: String
  loanToken_in: [String!]
  loanToken_not_in: [String!]
  loanToken_contains: String
  loanToken_not_contains: String
  closer: String
  closer_not: String
  closer_in: [String!]
  closer_not_in: [String!]
  closer_contains: String
  closer_not_contains: String
  positionCloseSize: String
  positionCloseSize_not: String
  positionCloseSize_gt: String
  positionCloseSize_lt: String
  positionCloseSize_gte: String
  positionCloseSize_lte: String
  positionCloseSize_in: [String!]
  positionCloseSize_not_in: [String!]
  loanCloseAmount: String
  loanCloseAmount_not: String
  loanCloseAmount_gt: String
  loanCloseAmount_lt: String
  loanCloseAmount_gte: String
  loanCloseAmount_lte: String
  loanCloseAmount_in: [String!]
  loanCloseAmount_not_in: [String!]
  exitPrice: String
  exitPrice_not: String
  exitPrice_gt: String
  exitPrice_lt: String
  exitPrice_gte: String
  exitPrice_lte: String
  exitPrice_in: [String!]
  exitPrice_not_in: [String!]
  currentLeverage: String
  currentLeverage_not: String
  currentLeverage_gt: String
  currentLeverage_lt: String
  currentLeverage_gte: String
  currentLeverage_lte: String
  currentLeverage_in: [String!]
  currentLeverage_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input Conversion_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  _fromToken: String
  _fromToken_not: String
  _fromToken_gt: String
  _fromToken_lt: String
  _fromToken_gte: String
  _fromToken_lte: String
  _fromToken_in: [String!]
  _fromToken_not_in: [String!]
  _fromToken_contains: String
  _fromToken_not_contains: String
  _fromToken_starts_with: String
  _fromToken_not_starts_with: String
  _fromToken_ends_with: String
  _fromToken_not_ends_with: String
  _toToken: String
  _toToken_not: String
  _toToken_gt: String
  _toToken_lt: String
  _toToken_gte: String
  _toToken_lte: String
  _toToken_in: [String!]
  _toToken_not_in: [String!]
  _toToken_contains: String
  _toToken_not_contains: String
  _toToken_starts_with: String
  _toToken_not_starts_with: String
  _toToken_ends_with: String
  _toToken_not_ends_with: String
  _trader: String
  _trader_not: String
  _trader_in: [String!]
  _trader_not_in: [String!]
  _trader_contains: String
  _trader_not_contains: String
  _amount: String
  _amount_not: String
  _amount_gt: String
  _amount_lt: String
  _amount_gte: String
  _amount_lte: String
  _amount_in: [String!]
  _amount_not_in: [String!]
  _return: String
  _return_not: String
  _return_gt: String
  _return_lt: String
  _return_gte: String
  _return_lte: String
  _return_in: [String!]
  _return_not_in: [String!]
  _conversionFee: String
  _conversionFee_not: String
  _conversionFee_gt: String
  _conversionFee_lt: String
  _conversionFee_gte: String
  _conversionFee_lte: String
  _conversionFee_in: [String!]
  _conversionFee_not_in: [String!]
  _protocolFee: String
  _protocolFee_not: String
  _protocolFee_gt: String
  _protocolFee_lt: String
  _protocolFee_gte: String
  _protocolFee_lte: String
  _protocolFee_in: [String!]
  _protocolFee_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_gt: String
  emittedBy_lt: String
  emittedBy_gte: String
  emittedBy_lte: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  emittedBy_starts_with: String
  emittedBy_not_starts_with: String
  emittedBy_ends_with: String
  emittedBy_not_ends_with: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
}
input ConverterRegistry_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  numConverters: Int
  numConverters_not: Int
  numConverters_gt: Int
  numConverters_lt: Int
  numConverters_gte: Int
  numConverters_lte: Int
  numConverters_in: [Int!]
  numConverters_not_in: [Int!]
}
input CrossTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  direction: CrossDirection
  direction_not: CrossDirection
  direction_in: [CrossDirection!]
  direction_not_in: [CrossDirection!]
  sourceChain: BridgeChain
  sourceChain_not: BridgeChain
  sourceChain_in: [BridgeChain!]
  sourceChain_not_in: [BridgeChain!]
  destinationChain: BridgeChain
  destinationChain_not: BridgeChain
  destinationChain_in: [BridgeChain!]
  destinationChain_not_in: [BridgeChain!]
  votes: Int
  votes_not: Int
  votes_gt: Int
  votes_lt: Int
  votes_gte: Int
  votes_lte: Int
  votes_in: [Int!]
  votes_not_in: [Int!]
  status: CrossStatus
  status_not: CrossStatus
  status_in: [CrossStatus!]
  status_not_in: [CrossStatus!]
  originalTokenAddress: String
  originalTokenAddress_not: String
  originalTokenAddress_in: [String!]
  originalTokenAddress_not_in: [String!]
  originalTokenAddress_contains: String
  originalTokenAddress_not_contains: String
  tokenAddress: String
  tokenAddress_not: String
  tokenAddress_in: [String!]
  tokenAddress_not_in: [String!]
  tokenAddress_contains: String
  tokenAddress_not_contains: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  sideToken: String
  sideToken_not: String
  sideToken_gt: String
  sideToken_lt: String
  sideToken_gte: String
  sideToken_lte: String
  sideToken_in: [String!]
  sideToken_not_in: [String!]
  sideToken_contains: String
  sideToken_not_contains: String
  sideToken_starts_with: String
  sideToken_not_starts_with: String
  sideToken_ends_with: String
  sideToken_not_ends_with: String
  rskUser: String
  rskUser_not: String
  rskUser_gt: String
  rskUser_lt: String
  rskUser_gte: String
  rskUser_lte: String
  rskUser_in: [String!]
  rskUser_not_in: [String!]
  rskUser_contains: String
  rskUser_not_contains: String
  rskUser_starts_with: String
  rskUser_not_starts_with: String
  rskUser_ends_with: String
  rskUser_not_ends_with: String
  receiver: String
  receiver_not: String
  receiver_in: [String!]
  receiver_not_in: [String!]
  receiver_contains: String
  receiver_not_contains: String
  sender: String
  sender_not: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_not_contains: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  sourceChainBlockHash: String
  sourceChainBlockHash_not: String
  sourceChainBlockHash_in: [String!]
  sourceChainBlockHash_not_in: [String!]
  sourceChainBlockHash_contains: String
  sourceChainBlockHash_not_contains: String
  sourceChainTransactionHash: String
  sourceChainTransactionHash_not: String
  sourceChainTransactionHash_in: [String!]
  sourceChainTransactionHash_not_in: [String!]
  sourceChainTransactionHash_contains: String
  sourceChainTransactionHash_not_contains: String
  createdAtTx: String
  createdAtTx_not: String
  createdAtTx_gt: String
  createdAtTx_lt: String
  createdAtTx_gte: String
  createdAtTx_lte: String
  createdAtTx_in: [String!]
  createdAtTx_not_in: [String!]
  createdAtTx_contains: String
  createdAtTx_not_contains: String
  createdAtTx_starts_with: String
  createdAtTx_not_starts_with: String
  createdAtTx_ends_with: String
  createdAtTx_not_ends_with: String
  createdAtTimestamp: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_lt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_not_in: [Int!]
  updatedAtTx: String
  updatedAtTx_not: String
  updatedAtTx_gt: String
  updatedAtTx_lt: String
  updatedAtTx_gte: String
  updatedAtTx_lte: String
  updatedAtTx_in: [String!]
  updatedAtTx_not_in: [String!]
  updatedAtTx_contains: String
  updatedAtTx_not_contains: String
  updatedAtTx_starts_with: String
  updatedAtTx_not_starts_with: String
  updatedAtTx_ends_with: String
  updatedAtTx_not_ends_with: String
  updatedAtTimestamp: Int
  updatedAtTimestamp_not: Int
  updatedAtTimestamp_gt: Int
  updatedAtTimestamp_lt: Int
  updatedAtTimestamp_gte: Int
  updatedAtTimestamp_lte: Int
  updatedAtTimestamp_in: [Int!]
  updatedAtTimestamp_not_in: [Int!]
}
input DepositCollateral_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  depositAmount: String
  depositAmount_not: String
  depositAmount_gt: String
  depositAmount_lt: String
  depositAmount_gte: String
  depositAmount_lte: String
  depositAmount_in: [String!]
  depositAmount_not_in: [String!]
  rate: String
  rate_not: String
  rate_gt: String
  rate_lt: String
  rate_gte: String
  rate_lte: String
  rate_in: [String!]
  rate_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input Deposit_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  to: String
  to_not: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_not_contains: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input FastBTCBridgeStat_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalAmountBTCInitialized: String
  totalAmountBTCInitialized_not: String
  totalAmountBTCInitialized_gt: String
  totalAmountBTCInitialized_lt: String
  totalAmountBTCInitialized_gte: String
  totalAmountBTCInitialized_lte: String
  totalAmountBTCInitialized_in: [String!]
  totalAmountBTCInitialized_not_in: [String!]
  totalAmountBTCSending: String
  totalAmountBTCSending_not: String
  totalAmountBTCSending_gt: String
  totalAmountBTCSending_lt: String
  totalAmountBTCSending_gte: String
  totalAmountBTCSending_lte: String
  totalAmountBTCSending_in: [String!]
  totalAmountBTCSending_not_in: [String!]
  totalAmountBTCMined: String
  totalAmountBTCMined_not: String
  totalAmountBTCMined_gt: String
  totalAmountBTCMined_lt: String
  totalAmountBTCMined_gte: String
  totalAmountBTCMined_lte: String
  totalAmountBTCMined_in: [String!]
  totalAmountBTCMined_not_in: [String!]
  totalFeesBTC: String
  totalFeesBTC_not: String
  totalFeesBTC_gt: String
  totalFeesBTC_lt: String
  totalFeesBTC_gte: String
  totalFeesBTC_lte: String
  totalFeesBTC_in: [String!]
  totalFeesBTC_not_in: [String!]
  totalAmountBTCRefunded: String
  totalAmountBTCRefunded_not: String
  totalAmountBTCRefunded_gt: String
  totalAmountBTCRefunded_lt: String
  totalAmountBTCRefunded_gte: String
  totalAmountBTCRefunded_lte: String
  totalAmountBTCRefunded_in: [String!]
  totalAmountBTCRefunded_not_in: [String!]
  createdAtTx: String
  createdAtTx_not: String
  createdAtTx_gt: String
  createdAtTx_lt: String
  createdAtTx_gte: String
  createdAtTx_lte: String
  createdAtTx_in: [String!]
  createdAtTx_not_in: [String!]
  createdAtTx_contains: String
  createdAtTx_not_contains: String
  createdAtTx_starts_with: String
  createdAtTx_not_starts_with: String
  createdAtTx_ends_with: String
  createdAtTx_not_ends_with: String
  updatedAtTx: String
  updatedAtTx_not: String
  updatedAtTx_gt: String
  updatedAtTx_lt: String
  updatedAtTx_gte: String
  updatedAtTx_lte: String
  updatedAtTx_in: [String!]
  updatedAtTx_not_in: [String!]
  updatedAtTx_contains: String
  updatedAtTx_not_contains: String
  updatedAtTx_starts_with: String
  updatedAtTx_not_starts_with: String
  updatedAtTx_ends_with: String
  updatedAtTx_not_ends_with: String
}
input Federation_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  bridge: String
  bridge_not: String
  bridge_gt: String
  bridge_lt: String
  bridge_gte: String
  bridge_lte: String
  bridge_in: [String!]
  bridge_not_in: [String!]
  bridge_contains: String
  bridge_not_contains: String
  bridge_starts_with: String
  bridge_not_starts_with: String
  bridge_ends_with: String
  bridge_not_ends_with: String
  totalVotes: Int
  totalVotes_not: Int
  totalVotes_gt: Int
  totalVotes_lt: Int
  totalVotes_gte: Int
  totalVotes_lte: Int
  totalVotes_in: [Int!]
  totalVotes_not_in: [Int!]
  totalExecuted: Int
  totalExecuted_not: Int
  totalExecuted_gt: Int
  totalExecuted_lt: Int
  totalExecuted_gte: Int
  totalExecuted_lte: Int
  totalExecuted_in: [Int!]
  totalExecuted_not_in: [Int!]
  members: [String!]
  members_not: [String!]
  members_contains: [String!]
  members_not_contains: [String!]
  createdAtTx: String
  createdAtTx_not: String
  createdAtTx_gt: String
  createdAtTx_lt: String
  createdAtTx_gte: String
  createdAtTx_lte: String
  createdAtTx_in: [String!]
  createdAtTx_not_in: [String!]
  createdAtTx_contains: String
  createdAtTx_not_contains: String
  createdAtTx_starts_with: String
  createdAtTx_not_starts_with: String
  createdAtTx_ends_with: String
  createdAtTx_not_ends_with: String
  updatedAtTx: String
  updatedAtTx_not: String
  updatedAtTx_gt: String
  updatedAtTx_lt: String
  updatedAtTx_gte: String
  updatedAtTx_lte: String
  updatedAtTx_in: [String!]
  updatedAtTx_not_in: [String!]
  updatedAtTx_contains: String
  updatedAtTx_not_contains: String
  updatedAtTx_starts_with: String
  updatedAtTx_not_starts_with: String
  updatedAtTx_ends_with: String
  updatedAtTx_not_ends_with: String
}
input FeeSharingTokensTransferred_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  sender: String
  sender_not: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_not_contains: String
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
}
input ICandleStick_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_not_contains: String
  baseToken_starts_with: String
  baseToken_not_starts_with: String
  baseToken_ends_with: String
  baseToken_not_ends_with: String
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_not_contains: String
  quoteToken_starts_with: String
  quoteToken_not_starts_with: String
  quoteToken_ends_with: String
  quoteToken_not_ends_with: String
  open: String
  open_not: String
  open_gt: String
  open_lt: String
  open_gte: String
  open_lte: String
  open_in: [String!]
  open_not_in: [String!]
  high: String
  high_not: String
  high_gt: String
  high_lt: String
  high_gte: String
  high_lte: String
  high_in: [String!]
  high_not_in: [String!]
  low: String
  low_not: String
  low_gt: String
  low_lt: String
  low_gte: String
  low_lte: String
  low_in: [String!]
  low_not_in: [String!]
  close: String
  close_not: String
  close_gt: String
  close_lt: String
  close_gte: String
  close_lte: String
  close_in: [String!]
  close_not_in: [String!]
  txCount: Int
  txCount_not: Int
  txCount_gt: Int
  txCount_lt: Int
  txCount_gte: Int
  txCount_lte: Int
  txCount_in: [Int!]
  txCount_not_in: [Int!]
  totalVolume: String
  totalVolume_not: String
  totalVolume_gt: String
  totalVolume_lt: String
  totalVolume_gte: String
  totalVolume_lte: String
  totalVolume_in: [String!]
  totalVolume_not_in: [String!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
}
input LendingHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lender: String
  lender_not: String
  lender_gt: String
  lender_lt: String
  lender_gte: String
  lender_lte: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  lender_starts_with: String
  lender_not_starts_with: String
  lender_ends_with: String
  lender_not_ends_with: String
  type: LendingHistoryType
  type_not: LendingHistoryType
  type_in: [LendingHistoryType!]
  type_not_in: [LendingHistoryType!]
  lendingPool: String
  lendingPool_not: String
  lendingPool_gt: String
  lendingPool_lt: String
  lendingPool_gte: String
  lendingPool_lte: String
  lendingPool_in: [String!]
  lendingPool_not_in: [String!]
  lendingPool_contains: String
  lendingPool_not_contains: String
  lendingPool_starts_with: String
  lendingPool_not_starts_with: String
  lendingPool_ends_with: String
  lendingPool_not_ends_with: String
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_not_contains: String
  asset_starts_with: String
  asset_not_starts_with: String
  asset_ends_with: String
  asset_not_ends_with: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  loanTokenAmount: String
  loanTokenAmount_not: String
  loanTokenAmount_gt: String
  loanTokenAmount_lt: String
  loanTokenAmount_gte: String
  loanTokenAmount_lte: String
  loanTokenAmount_in: [String!]
  loanTokenAmount_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  emittedBy: String
  emittedBy_not: String
  emittedBy_gt: String
  emittedBy_lt: String
  emittedBy_gte: String
  emittedBy_lte: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  emittedBy_starts_with: String
  emittedBy_not_starts_with: String
  emittedBy_ends_with: String
  emittedBy_not_ends_with: String
  userLendingHistory: String
  userLendingHistory_not: String
  userLendingHistory_gt: String
  userLendingHistory_lt: String
  userLendingHistory_gte: String
  userLendingHistory_lte: String
  userLendingHistory_in: [String!]
  userLendingHistory_not_in: [String!]
  userLendingHistory_contains: String
  userLendingHistory_not_contains: String
  userLendingHistory_starts_with: String
  userLendingHistory_not_starts_with: String
  userLendingHistory_ends_with: String
  userLendingHistory_not_ends_with: String
}
input LendingPool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  underlyingAsset: String
  underlyingAsset_not: String
  underlyingAsset_gt: String
  underlyingAsset_lt: String
  underlyingAsset_gte: String
  underlyingAsset_lte: String
  underlyingAsset_in: [String!]
  underlyingAsset_not_in: [String!]
  underlyingAsset_contains: String
  underlyingAsset_not_contains: String
  underlyingAsset_starts_with: String
  underlyingAsset_not_starts_with: String
  underlyingAsset_ends_with: String
  underlyingAsset_not_ends_with: String
  poolTokenBalance: String
  poolTokenBalance_not: String
  poolTokenBalance_gt: String
  poolTokenBalance_lt: String
  poolTokenBalance_gte: String
  poolTokenBalance_lte: String
  poolTokenBalance_in: [String!]
  poolTokenBalance_not_in: [String!]
  assetBalance: String
  assetBalance_not: String
  assetBalance_gt: String
  assetBalance_lt: String
  assetBalance_gte: String
  assetBalance_lte: String
  assetBalance_in: [String!]
  assetBalance_not_in: [String!]
  totalAssetLent: String
  totalAssetLent_not: String
  totalAssetLent_gt: String
  totalAssetLent_lt: String
  totalAssetLent_gte: String
  totalAssetLent_lte: String
  totalAssetLent_in: [String!]
  totalAssetLent_not_in: [String!]
}
input Liquidate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  liquidator: String
  liquidator_not: String
  liquidator_in: [String!]
  liquidator_not_in: [String!]
  liquidator_contains: String
  liquidator_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  lender: String
  lender_not: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  loanToken: String
  loanToken_not: String
  loanToken_in: [String!]
  loanToken_not_in: [String!]
  loanToken_contains: String
  loanToken_not_contains: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_not_contains: String
  repayAmount: String
  repayAmount_not: String
  repayAmount_gt: String
  repayAmount_lt: String
  repayAmount_gte: String
  repayAmount_lte: String
  repayAmount_in: [String!]
  repayAmount_not_in: [String!]
  collateralWithdrawAmount: String
  collateralWithdrawAmount_not: String
  collateralWithdrawAmount_gt: String
  collateralWithdrawAmount_lt: String
  collateralWithdrawAmount_gte: String
  collateralWithdrawAmount_lte: String
  collateralWithdrawAmount_in: [String!]
  collateralWithdrawAmount_not_in: [String!]
  collateralToLoanRate: String
  collateralToLoanRate_not: String
  collateralToLoanRate_gt: String
  collateralToLoanRate_lt: String
  collateralToLoanRate_gte: String
  collateralToLoanRate_lte: String
  collateralToLoanRate_in: [String!]
  collateralToLoanRate_not_in: [String!]
  currentMargin: String
  currentMargin_not: String
  currentMargin_gt: String
  currentMargin_lt: String
  currentMargin_gte: String
  currentMargin_lte: String
  currentMargin_in: [String!]
  currentMargin_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input LiquidityHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  userLiquidityHistory: String
  userLiquidityHistory_not: String
  userLiquidityHistory_gt: String
  userLiquidityHistory_lt: String
  userLiquidityHistory_gte: String
  userLiquidityHistory_lte: String
  userLiquidityHistory_in: [String!]
  userLiquidityHistory_not_in: [String!]
  userLiquidityHistory_contains: String
  userLiquidityHistory_not_contains: String
  userLiquidityHistory_starts_with: String
  userLiquidityHistory_not_starts_with: String
  userLiquidityHistory_ends_with: String
  userLiquidityHistory_not_ends_with: String
  type: LiquidityHistoryType
  type_not: LiquidityHistoryType
  type_in: [LiquidityHistoryType!]
  type_not_in: [LiquidityHistoryType!]
  provider: String
  provider_not: String
  provider_gt: String
  provider_lt: String
  provider_gte: String
  provider_lte: String
  provider_in: [String!]
  provider_not_in: [String!]
  provider_contains: String
  provider_not_contains: String
  provider_starts_with: String
  provider_not_starts_with: String
  provider_ends_with: String
  provider_not_ends_with: String
  reserveToken: String
  reserveToken_not: String
  reserveToken_gt: String
  reserveToken_lt: String
  reserveToken_gte: String
  reserveToken_lte: String
  reserveToken_in: [String!]
  reserveToken_not_in: [String!]
  reserveToken_contains: String
  reserveToken_not_contains: String
  reserveToken_starts_with: String
  reserveToken_not_starts_with: String
  reserveToken_ends_with: String
  reserveToken_not_ends_with: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  newBalance: String
  newBalance_not: String
  newBalance_gt: String
  newBalance_lt: String
  newBalance_gte: String
  newBalance_lte: String
  newBalance_in: [String!]
  newBalance_not_in: [String!]
  newSupply: String
  newSupply_not: String
  newSupply_gt: String
  newSupply_lt: String
  newSupply_gte: String
  newSupply_lte: String
  newSupply_in: [String!]
  newSupply_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  liquidityPool: String
  liquidityPool_not: String
  liquidityPool_gt: String
  liquidityPool_lt: String
  liquidityPool_gte: String
  liquidityPool_lte: String
  liquidityPool_in: [String!]
  liquidityPool_not_in: [String!]
  liquidityPool_contains: String
  liquidityPool_not_contains: String
  liquidityPool_starts_with: String
  liquidityPool_not_starts_with: String
  liquidityPool_ends_with: String
  liquidityPool_not_ends_with: String
  emittedBy: String
  emittedBy_not: String
  emittedBy_gt: String
  emittedBy_lt: String
  emittedBy_gte: String
  emittedBy_lte: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  emittedBy_starts_with: String
  emittedBy_not_starts_with: String
  emittedBy_ends_with: String
  emittedBy_not_ends_with: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input LiquidityMiningAllocationPoint_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  allocationPoint: String
  allocationPoint_not: String
  allocationPoint_gt: String
  allocationPoint_lt: String
  allocationPoint_gte: String
  allocationPoint_lte: String
  allocationPoint_in: [String!]
  allocationPoint_not_in: [String!]
  rewardPerBlock: String
  rewardPerBlock_not: String
  rewardPerBlock_gt: String
  rewardPerBlock_lt: String
  rewardPerBlock_gte: String
  rewardPerBlock_lte: String
  rewardPerBlock_in: [String!]
  rewardPerBlock_not_in: [String!]
  ammPoolToken: String
  ammPoolToken_not: String
  ammPoolToken_gt: String
  ammPoolToken_lt: String
  ammPoolToken_gte: String
  ammPoolToken_lte: String
  ammPoolToken_in: [String!]
  ammPoolToken_not_in: [String!]
  ammPoolToken_contains: String
  ammPoolToken_not_contains: String
  ammPoolToken_starts_with: String
  ammPoolToken_not_starts_with: String
  ammPoolToken_ends_with: String
  ammPoolToken_not_ends_with: String
  lendingPoolToken: String
  lendingPoolToken_not: String
  lendingPoolToken_gt: String
  lendingPoolToken_lt: String
  lendingPoolToken_gte: String
  lendingPoolToken_lte: String
  lendingPoolToken_in: [String!]
  lendingPoolToken_not_in: [String!]
  lendingPoolToken_contains: String
  lendingPoolToken_not_contains: String
  lendingPoolToken_starts_with: String
  lendingPoolToken_not_starts_with: String
  lendingPoolToken_ends_with: String
  lendingPoolToken_not_ends_with: String
  poolTokenAddedTimestamp: Int
  poolTokenAddedTimestamp_not: Int
  poolTokenAddedTimestamp_gt: Int
  poolTokenAddedTimestamp_lt: Int
  poolTokenAddedTimestamp_gte: Int
  poolTokenAddedTimestamp_lte: Int
  poolTokenAddedTimestamp_in: [Int!]
  poolTokenAddedTimestamp_not_in: [Int!]
  poolTokenUpdatedTimestamp: Int
  poolTokenUpdatedTimestamp_not: Int
  poolTokenUpdatedTimestamp_gt: Int
  poolTokenUpdatedTimestamp_lt: Int
  poolTokenUpdatedTimestamp_gte: Int
  poolTokenUpdatedTimestamp_lte: Int
  poolTokenUpdatedTimestamp_in: [Int!]
  poolTokenUpdatedTimestamp_not_in: [Int!]
  poolTokenAddedBlock: Int
  poolTokenAddedBlock_not: Int
  poolTokenAddedBlock_gt: Int
  poolTokenAddedBlock_lt: Int
  poolTokenAddedBlock_gte: Int
  poolTokenAddedBlock_lte: Int
  poolTokenAddedBlock_in: [Int!]
  poolTokenAddedBlock_not_in: [Int!]
  poolTokenUpdatedBlock: Int
  poolTokenUpdatedBlock_not: Int
  poolTokenUpdatedBlock_gt: Int
  poolTokenUpdatedBlock_lt: Int
  poolTokenUpdatedBlock_gte: Int
  poolTokenUpdatedBlock_lte: Int
  poolTokenUpdatedBlock_in: [Int!]
  poolTokenUpdatedBlock_not_in: [Int!]
}
input LiquidityMiningGlobal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalAllocationPoint: String
  totalAllocationPoint_not: String
  totalAllocationPoint_gt: String
  totalAllocationPoint_lt: String
  totalAllocationPoint_gte: String
  totalAllocationPoint_lte: String
  totalAllocationPoint_in: [String!]
  totalAllocationPoint_not_in: [String!]
  totalRewardPerBlock: String
  totalRewardPerBlock_not: String
  totalRewardPerBlock_gt: String
  totalRewardPerBlock_lt: String
  totalRewardPerBlock_gte: String
  totalRewardPerBlock_lte: String
  totalRewardPerBlock_in: [String!]
  totalRewardPerBlock_not_in: [String!]
}
input LiquidityPoolToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  liquidityPool: String
  liquidityPool_not: String
  liquidityPool_gt: String
  liquidityPool_lt: String
  liquidityPool_gte: String
  liquidityPool_lte: String
  liquidityPool_in: [String!]
  liquidityPool_not_in: [String!]
  liquidityPool_contains: String
  liquidityPool_not_contains: String
  liquidityPool_starts_with: String
  liquidityPool_not_starts_with: String
  liquidityPool_ends_with: String
  liquidityPool_not_ends_with: String
  poolToken: String
  poolToken_not: String
  poolToken_gt: String
  poolToken_lt: String
  poolToken_gte: String
  poolToken_lte: String
  poolToken_in: [String!]
  poolToken_not_in: [String!]
  poolToken_contains: String
  poolToken_not_contains: String
  poolToken_starts_with: String
  poolToken_not_starts_with: String
  poolToken_ends_with: String
  poolToken_not_ends_with: String
  volumeBought: String
  volumeBought_not: String
  volumeBought_gt: String
  volumeBought_lt: String
  volumeBought_gte: String
  volumeBought_lte: String
  volumeBought_in: [String!]
  volumeBought_not_in: [String!]
  volumeSold: String
  volumeSold_not: String
  volumeSold_gt: String
  volumeSold_lt: String
  volumeSold_gte: String
  volumeSold_lte: String
  volumeSold_in: [String!]
  volumeSold_not_in: [String!]
  totalVolume: String
  totalVolume_not: String
  totalVolume_gt: String
  totalVolume_lt: String
  totalVolume_gte: String
  totalVolume_lte: String
  totalVolume_in: [String!]
  totalVolume_not_in: [String!]
}
input LiquidityPool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: Int
  type_not: Int
  type_gt: Int
  type_lt: Int
  type_gte: Int
  type_lte: Int
  type_in: [Int!]
  type_not_in: [Int!]
  version: Int
  version_not: Int
  version_gt: Int
  version_lt: Int
  version_gte: Int
  version_lte: Int
  version_in: [Int!]
  version_not_in: [Int!]
  smartToken: String
  smartToken_not: String
  smartToken_gt: String
  smartToken_lt: String
  smartToken_gte: String
  smartToken_lte: String
  smartToken_in: [String!]
  smartToken_not_in: [String!]
  smartToken_contains: String
  smartToken_not_contains: String
  smartToken_starts_with: String
  smartToken_not_starts_with: String
  smartToken_ends_with: String
  smartToken_not_ends_with: String
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_not_contains: String
  token0_starts_with: String
  token0_not_starts_with: String
  token0_ends_with: String
  token0_not_ends_with: String
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_not_contains: String
  token1_starts_with: String
  token1_not_starts_with: String
  token1_ends_with: String
  token1_not_ends_with: String
  token0Balance: String
  token0Balance_not: String
  token0Balance_gt: String
  token0Balance_lt: String
  token0Balance_gte: String
  token0Balance_lte: String
  token0Balance_in: [String!]
  token0Balance_not_in: [String!]
  token1Balance: String
  token1Balance_not: String
  token1Balance_gt: String
  token1Balance_lt: String
  token1Balance_gte: String
  token1Balance_lte: String
  token1Balance_in: [String!]
  token1Balance_not_in: [String!]
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_not_contains: String
  owner_starts_with: String
  owner_not_starts_with: String
  owner_ends_with: String
  owner_not_ends_with: String
  conversionFee: String
  conversionFee_not: String
  conversionFee_gt: String
  conversionFee_lt: String
  conversionFee_gte: String
  conversionFee_lte: String
  conversionFee_in: [String!]
  conversionFee_not_in: [String!]
  activated: Boolean
  activated_not: Boolean
  activated_in: [Boolean!]
  activated_not_in: [Boolean!]
  maxConversionFee: String
  maxConversionFee_not: String
  maxConversionFee_gt: String
  maxConversionFee_lt: String
  maxConversionFee_gte: String
  maxConversionFee_lte: String
  maxConversionFee_in: [String!]
  maxConversionFee_not_in: [String!]
  createdAtTimestamp: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_lt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_not_in: [Int!]
  createdAtBlockNumber: Int
  createdAtBlockNumber_not: Int
  createdAtBlockNumber_gt: Int
  createdAtBlockNumber_lt: Int
  createdAtBlockNumber_gte: Int
  createdAtBlockNumber_lte: Int
  createdAtBlockNumber_in: [Int!]
  createdAtBlockNumber_not_in: [Int!]
  createdAtTransaction: String
  createdAtTransaction_not: String
  createdAtTransaction_gt: String
  createdAtTransaction_lt: String
  createdAtTransaction_gte: String
  createdAtTransaction_lte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_contains: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_starts_with: String
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_not_ends_with: String
  currentConverterRegistry: String
  currentConverterRegistry_not: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_lt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_contains: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_not_ends_with: String
}
input Loan_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  loanToken: String
  loanToken_not: String
  loanToken_gt: String
  loanToken_lt: String
  loanToken_gte: String
  loanToken_lte: String
  loanToken_in: [String!]
  loanToken_not_in: [String!]
  loanToken_contains: String
  loanToken_not_contains: String
  loanToken_starts_with: String
  loanToken_not_starts_with: String
  loanToken_ends_with: String
  loanToken_not_ends_with: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_gt: String
  collateralToken_lt: String
  collateralToken_gte: String
  collateralToken_lte: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_not_contains: String
  collateralToken_starts_with: String
  collateralToken_not_starts_with: String
  collateralToken_ends_with: String
  collateralToken_not_ends_with: String
  type: LoanType
  type_not: LoanType
  type_in: [LoanType!]
  type_not_in: [LoanType!]
  startTimestamp: Int
  startTimestamp_not: Int
  startTimestamp_gt: Int
  startTimestamp_lt: Int
  startTimestamp_gte: Int
  startTimestamp_lte: Int
  startTimestamp_in: [Int!]
  startTimestamp_not_in: [Int!]
  endTimestamp: Int
  endTimestamp_not: Int
  endTimestamp_gt: Int
  endTimestamp_lt: Int
  endTimestamp_gte: Int
  endTimestamp_lte: Int
  endTimestamp_in: [Int!]
  endTimestamp_not_in: [Int!]
  borrowedAmount: String
  borrowedAmount_not: String
  borrowedAmount_gt: String
  borrowedAmount_lt: String
  borrowedAmount_gte: String
  borrowedAmount_lte: String
  borrowedAmount_in: [String!]
  borrowedAmount_not_in: [String!]
  startBorrowedAmount: String
  startBorrowedAmount_not: String
  startBorrowedAmount_gt: String
  startBorrowedAmount_lt: String
  startBorrowedAmount_gte: String
  startBorrowedAmount_lte: String
  startBorrowedAmount_in: [String!]
  startBorrowedAmount_not_in: [String!]
  maxBorrowedAmount: String
  maxBorrowedAmount_not: String
  maxBorrowedAmount_gt: String
  maxBorrowedAmount_lt: String
  maxBorrowedAmount_gte: String
  maxBorrowedAmount_lte: String
  maxBorrowedAmount_in: [String!]
  maxBorrowedAmount_not_in: [String!]
  positionSize: String
  positionSize_not: String
  positionSize_gt: String
  positionSize_lt: String
  positionSize_gte: String
  positionSize_lte: String
  positionSize_in: [String!]
  positionSize_not_in: [String!]
  startPositionSize: String
  startPositionSize_not: String
  startPositionSize_gt: String
  startPositionSize_lt: String
  startPositionSize_gte: String
  startPositionSize_lte: String
  startPositionSize_in: [String!]
  startPositionSize_not_in: [String!]
  maximumPositionSize: String
  maximumPositionSize_not: String
  maximumPositionSize_gt: String
  maximumPositionSize_lt: String
  maximumPositionSize_gte: String
  maximumPositionSize_lte: String
  maximumPositionSize_in: [String!]
  maximumPositionSize_not_in: [String!]
  startRate: String
  startRate_not: String
  startRate_gt: String
  startRate_lt: String
  startRate_gte: String
  startRate_lte: String
  startRate_in: [String!]
  startRate_not_in: [String!]
  isOpen: Boolean
  isOpen_not: Boolean
  isOpen_in: [Boolean!]
  isOpen_not_in: [Boolean!]
  nextRollover: Int
  nextRollover_not: Int
  nextRollover_gt: Int
  nextRollover_lt: Int
  nextRollover_gte: Int
  nextRollover_lte: Int
  nextRollover_in: [Int!]
  nextRollover_not_in: [Int!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalBought: String
  totalBought_not: String
  totalBought_gt: String
  totalBought_lt: String
  totalBought_gte: String
  totalBought_lte: String
  totalBought_in: [String!]
  totalBought_not_in: [String!]
  totalSold: String
  totalSold_not: String
  totalSold_gt: String
  totalSold_lt: String
  totalSold_gte: String
  totalSold_lte: String
  totalSold_in: [String!]
  totalSold_not_in: [String!]
  averageBuyPrice: String
  averageBuyPrice_not: String
  averageBuyPrice_gt: String
  averageBuyPrice_lt: String
  averageBuyPrice_gte: String
  averageBuyPrice_lte: String
  averageBuyPrice_in: [String!]
  averageBuyPrice_not_in: [String!]
  averageSellPrice: String
  averageSellPrice_not: String
  averageSellPrice_gt: String
  averageSellPrice_lt: String
  averageSellPrice_gte: String
  averageSellPrice_lte: String
  averageSellPrice_in: [String!]
  averageSellPrice_not_in: [String!]
  realizedPnL: String
  realizedPnL_not: String
  realizedPnL_gt: String
  realizedPnL_lt: String
  realizedPnL_gte: String
  realizedPnL_lte: String
  realizedPnL_in: [String!]
  realizedPnL_not_in: [String!]
  realizedPnLPercent: String
  realizedPnLPercent_not: String
  realizedPnLPercent_gt: String
  realizedPnLPercent_lt: String
  realizedPnLPercent_gte: String
  realizedPnLPercent_lte: String
  realizedPnLPercent_in: [String!]
  realizedPnLPercent_not_in: [String!]
}
input MarginOrderCanceled_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_not_contains: String
  trader: String
  trader_not: String
  trader_in: [String!]
  trader_not_in: [String!]
  trader_contains: String
  trader_not_contains: String
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input MarginOrderFilled_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_not_contains: String
  trader: String
  trader_not: String
  trader_gt: String
  trader_lt: String
  trader_gte: String
  trader_lte: String
  trader_in: [String!]
  trader_not_in: [String!]
  trader_contains: String
  trader_not_contains: String
  trader_starts_with: String
  trader_not_starts_with: String
  trader_ends_with: String
  trader_not_ends_with: String
  principal: String
  principal_not: String
  principal_gt: String
  principal_lt: String
  principal_gte: String
  principal_lte: String
  principal_in: [String!]
  principal_not_in: [String!]
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  leverageAmount: String
  leverageAmount_not: String
  leverageAmount_gt: String
  leverageAmount_lt: String
  leverageAmount_gte: String
  leverageAmount_lte: String
  leverageAmount_in: [String!]
  leverageAmount_not_in: [String!]
  loanTokenAddress: String
  loanTokenAddress_not: String
  loanTokenAddress_in: [String!]
  loanTokenAddress_not_in: [String!]
  loanTokenAddress_contains: String
  loanTokenAddress_not_contains: String
  loanTokenSent: String
  loanTokenSent_not: String
  loanTokenSent_gt: String
  loanTokenSent_lt: String
  loanTokenSent_gte: String
  loanTokenSent_lte: String
  loanTokenSent_in: [String!]
  loanTokenSent_not_in: [String!]
  collateralTokenSent: String
  collateralTokenSent_not: String
  collateralTokenSent_gt: String
  collateralTokenSent_lt: String
  collateralTokenSent_gte: String
  collateralTokenSent_lte: String
  collateralTokenSent_in: [String!]
  collateralTokenSent_not_in: [String!]
  collateralTokenAddress: String
  collateralTokenAddress_not: String
  collateralTokenAddress_in: [String!]
  collateralTokenAddress_not_in: [String!]
  collateralTokenAddress_contains: String
  collateralTokenAddress_not_contains: String
  filledPrice: String
  filledPrice_not: String
  filledPrice_gt: String
  filledPrice_lt: String
  filledPrice_gte: String
  filledPrice_lte: String
  filledPrice_in: [String!]
  filledPrice_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input OrderCanceled_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_not_contains: String
  maker: String
  maker_not: String
  maker_in: [String!]
  maker_not_in: [String!]
  maker_contains: String
  maker_not_contains: String
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input OrderCreated_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_not_contains: String
  network: Network
  network_not: Network
  network_in: [Network!]
  network_not_in: [Network!]
  order_maker: String
  order_maker_not: String
  order_maker_in: [String!]
  order_maker_not_in: [String!]
  order_maker_contains: String
  order_maker_not_contains: String
  order_fromToken: String
  order_fromToken_not: String
  order_fromToken_in: [String!]
  order_fromToken_not_in: [String!]
  order_fromToken_contains: String
  order_fromToken_not_contains: String
  order_toToken: String
  order_toToken_not: String
  order_toToken_in: [String!]
  order_toToken_not_in: [String!]
  order_toToken_contains: String
  order_toToken_not_contains: String
  order_amountIn: String
  order_amountIn_not: String
  order_amountIn_gt: String
  order_amountIn_lt: String
  order_amountIn_gte: String
  order_amountIn_lte: String
  order_amountIn_in: [String!]
  order_amountIn_not_in: [String!]
  order_amountOutMin: String
  order_amountOutMin_not: String
  order_amountOutMin_gt: String
  order_amountOutMin_lt: String
  order_amountOutMin_gte: String
  order_amountOutMin_lte: String
  order_amountOutMin_in: [String!]
  order_amountOutMin_not_in: [String!]
  order_recipient: String
  order_recipient_not: String
  order_recipient_in: [String!]
  order_recipient_not_in: [String!]
  order_recipient_contains: String
  order_recipient_not_contains: String
  order_deadline: String
  order_deadline_not: String
  order_deadline_gt: String
  order_deadline_lt: String
  order_deadline_gte: String
  order_deadline_lte: String
  order_deadline_in: [String!]
  order_deadline_not_in: [String!]
  order_created: String
  order_created_not: String
  order_created_gt: String
  order_created_lt: String
  order_created_gte: String
  order_created_lte: String
  order_created_in: [String!]
  order_created_not_in: [String!]
  limitPrice: String
  limitPrice_not: String
  limitPrice_gt: String
  limitPrice_lt: String
  limitPrice_gte: String
  limitPrice_lte: String
  limitPrice_in: [String!]
  limitPrice_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input OrderFilled_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_not_contains: String
  maker: String
  maker_not: String
  maker_gt: String
  maker_lt: String
  maker_gte: String
  maker_lte: String
  maker_in: [String!]
  maker_not_in: [String!]
  maker_contains: String
  maker_not_contains: String
  maker_starts_with: String
  maker_not_starts_with: String
  maker_ends_with: String
  maker_not_ends_with: String
  amountIn: String
  amountIn_not: String
  amountIn_gt: String
  amountIn_lt: String
  amountIn_gte: String
  amountIn_lte: String
  amountIn_in: [String!]
  amountIn_not_in: [String!]
  amountOut: String
  amountOut_not: String
  amountOut_gt: String
  amountOut_lt: String
  amountOut_gte: String
  amountOut_lte: String
  amountOut_in: [String!]
  amountOut_not_in: [String!]
  path: [String!]
  path_not: [String!]
  path_contains: [String!]
  path_not_contains: [String!]
  filledPrice: String
  filledPrice_not: String
  filledPrice_gt: String
  filledPrice_lt: String
  filledPrice_gte: String
  filledPrice_lte: String
  filledPrice_in: [String!]
  filledPrice_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input OwnerUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  prevOwner: String
  prevOwner_not: String
  prevOwner_gt: String
  prevOwner_lt: String
  prevOwner_gte: String
  prevOwner_lte: String
  prevOwner_in: [String!]
  prevOwner_not_in: [String!]
  prevOwner_contains: String
  prevOwner_not_contains: String
  prevOwner_starts_with: String
  prevOwner_not_starts_with: String
  prevOwner_ends_with: String
  prevOwner_not_ends_with: String
  newOwner: String
  newOwner_not: String
  newOwner_gt: String
  newOwner_lt: String
  newOwner_gte: String
  newOwner_lte: String
  newOwner_in: [String!]
  newOwner_not_in: [String!]
  newOwner_contains: String
  newOwner_not_contains: String
  newOwner_starts_with: String
  newOwner_not_starts_with: String
  newOwner_ends_with: String
  newOwner_not_ends_with: String
  timestamp: String
  timestamp_not: String
  timestamp_gt: String
  timestamp_lt: String
  timestamp_gte: String
  timestamp_lte: String
  timestamp_in: [String!]
  timestamp_not_in: [String!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_gt: String
  emittedBy_lt: String
  emittedBy_gte: String
  emittedBy_lte: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  emittedBy_starts_with: String
  emittedBy_not_starts_with: String
  emittedBy_ends_with: String
  emittedBy_not_ends_with: String
}
input PayBorrowingFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  payer: String
  payer_not: String
  payer_in: [String!]
  payer_not_in: [String!]
  payer_contains: String
  payer_not_contains: String
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input PayLendingFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  payer: String
  payer_not: String
  payer_in: [String!]
  payer_not_in: [String!]
  payer_contains: String
  payer_not_contains: String
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input PayTradingFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  payer: String
  payer_not: String
  payer_in: [String!]
  payer_not_in: [String!]
  payer_contains: String
  payer_not_contains: String
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input PoolToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  liquidityPool: String
  liquidityPool_not: String
  liquidityPool_gt: String
  liquidityPool_lt: String
  liquidityPool_gte: String
  liquidityPool_lte: String
  liquidityPool_in: [String!]
  liquidityPool_not_in: [String!]
  liquidityPool_contains: String
  liquidityPool_not_contains: String
  liquidityPool_starts_with: String
  liquidityPool_not_starts_with: String
  liquidityPool_ends_with: String
  liquidityPool_not_ends_with: String
  underlyingAssets: [String!]
  underlyingAssets_not: [String!]
  underlyingAssets_contains: [String!]
  underlyingAssets_not_contains: [String!]
}
input Proposal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  created: String
  created_not: String
  created_gt: String
  created_lt: String
  created_gte: String
  created_lte: String
  created_in: [String!]
  created_not_in: [String!]
  created_contains: String
  created_not_contains: String
  created_starts_with: String
  created_not_starts_with: String
  created_ends_with: String
  created_not_ends_with: String
  canceled: String
  canceled_not: String
  canceled_gt: String
  canceled_lt: String
  canceled_gte: String
  canceled_lte: String
  canceled_in: [String!]
  canceled_not_in: [String!]
  canceled_contains: String
  canceled_not_contains: String
  canceled_starts_with: String
  canceled_not_starts_with: String
  canceled_ends_with: String
  canceled_not_ends_with: String
  executed: String
  executed_not: String
  executed_gt: String
  executed_lt: String
  executed_gte: String
  executed_lte: String
  executed_in: [String!]
  executed_not_in: [String!]
  executed_contains: String
  executed_not_contains: String
  executed_starts_with: String
  executed_not_starts_with: String
  executed_ends_with: String
  executed_not_ends_with: String
  queued: String
  queued_not: String
  queued_gt: String
  queued_lt: String
  queued_gte: String
  queued_lte: String
  queued_in: [String!]
  queued_not_in: [String!]
  queued_contains: String
  queued_not_contains: String
  queued_starts_with: String
  queued_not_starts_with: String
  queued_ends_with: String
  queued_not_ends_with: String
  votesFor: String
  votesFor_not: String
  votesFor_gt: String
  votesFor_lt: String
  votesFor_gte: String
  votesFor_lte: String
  votesFor_in: [String!]
  votesFor_not_in: [String!]
  votesAgainst: String
  votesAgainst_not: String
  votesAgainst_gt: String
  votesAgainst_lt: String
  votesAgainst_gte: String
  votesAgainst_lte: String
  votesAgainst_in: [String!]
  votesAgainst_not_in: [String!]
  countVotersFor: Int
  countVotersFor_not: Int
  countVotersFor_gt: Int
  countVotersFor_lt: Int
  countVotersFor_gte: Int
  countVotersFor_lte: Int
  countVotersFor_in: [Int!]
  countVotersFor_not_in: [Int!]
  countVotersAgainst: Int
  countVotersAgainst_not: Int
  countVotersAgainst_gt: Int
  countVotersAgainst_lt: Int
  countVotersAgainst_gte: Int
  countVotersAgainst_lte: Int
  countVotersAgainst_in: [Int!]
  countVotersAgainst_not_in: [Int!]
  proposalId: Int
  proposalId_not: Int
  proposalId_gt: Int
  proposalId_lt: Int
  proposalId_gte: Int
  proposalId_lte: Int
  proposalId_in: [Int!]
  proposalId_not_in: [Int!]
  proposer: String
  proposer_not: String
  proposer_in: [String!]
  proposer_not_in: [String!]
  proposer_contains: String
  proposer_not_contains: String
  targets: [String!]
  targets_not: [String!]
  targets_contains: [String!]
  targets_not_contains: [String!]
  values: [String!]
  values_not: [String!]
  values_contains: [String!]
  values_not_contains: [String!]
  signatures: [String!]
  signatures_not: [String!]
  signatures_contains: [String!]
  signatures_not_contains: [String!]
  startBlock: Int
  startBlock_not: Int
  startBlock_gt: Int
  startBlock_lt: Int
  startBlock_gte: Int
  startBlock_lte: Int
  startBlock_in: [Int!]
  startBlock_not_in: [Int!]
  endBlock: Int
  endBlock_not: Int
  endBlock_gt: Int
  endBlock_lt: Int
  endBlock_gte: Int
  endBlock_lte: Int
  endBlock_in: [Int!]
  endBlock_not_in: [Int!]
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
}
input ProtocolStats_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  tokens: [String!]
  tokens_not: [String!]
  tokens_contains: [String!]
  tokens_not_contains: [String!]
  usdStablecoin: String
  usdStablecoin_not: String
  usdStablecoin_gt: String
  usdStablecoin_lt: String
  usdStablecoin_gte: String
  usdStablecoin_lte: String
  usdStablecoin_in: [String!]
  usdStablecoin_not_in: [String!]
  usdStablecoin_contains: String
  usdStablecoin_not_contains: String
  usdStablecoin_starts_with: String
  usdStablecoin_not_starts_with: String
  usdStablecoin_ends_with: String
  usdStablecoin_not_ends_with: String
  btcUsdPrice: String
  btcUsdPrice_not: String
  btcUsdPrice_gt: String
  btcUsdPrice_lt: String
  btcUsdPrice_gte: String
  btcUsdPrice_lte: String
  btcUsdPrice_in: [String!]
  btcUsdPrice_not_in: [String!]
  totalUsers: Int
  totalUsers_not: Int
  totalUsers_gt: Int
  totalUsers_lt: Int
  totalUsers_gte: Int
  totalUsers_lte: Int
  totalUsers_in: [Int!]
  totalUsers_not_in: [Int!]
  totalMarginTradeVolumeUsd: String
  totalMarginTradeVolumeUsd_not: String
  totalMarginTradeVolumeUsd_gt: String
  totalMarginTradeVolumeUsd_lt: String
  totalMarginTradeVolumeUsd_gte: String
  totalMarginTradeVolumeUsd_lte: String
  totalMarginTradeVolumeUsd_in: [String!]
  totalMarginTradeVolumeUsd_not_in: [String!]
  totalCloseWithSwapVolumeUsd: String
  totalCloseWithSwapVolumeUsd_not: String
  totalCloseWithSwapVolumeUsd_gt: String
  totalCloseWithSwapVolumeUsd_lt: String
  totalCloseWithSwapVolumeUsd_gte: String
  totalCloseWithSwapVolumeUsd_lte: String
  totalCloseWithSwapVolumeUsd_in: [String!]
  totalCloseWithSwapVolumeUsd_not_in: [String!]
  totalDepositCollateralVolumeUsd: String
  totalDepositCollateralVolumeUsd_not: String
  totalDepositCollateralVolumeUsd_gt: String
  totalDepositCollateralVolumeUsd_lt: String
  totalDepositCollateralVolumeUsd_gte: String
  totalDepositCollateralVolumeUsd_lte: String
  totalDepositCollateralVolumeUsd_in: [String!]
  totalDepositCollateralVolumeUsd_not_in: [String!]
  totalLiquidateVolumeUsd: String
  totalLiquidateVolumeUsd_not: String
  totalLiquidateVolumeUsd_gt: String
  totalLiquidateVolumeUsd_lt: String
  totalLiquidateVolumeUsd_gte: String
  totalLiquidateVolumeUsd_lte: String
  totalLiquidateVolumeUsd_in: [String!]
  totalLiquidateVolumeUsd_not_in: [String!]
  totalAmmVolumeUsd: String
  totalAmmVolumeUsd_not: String
  totalAmmVolumeUsd_gt: String
  totalAmmVolumeUsd_lt: String
  totalAmmVolumeUsd_gte: String
  totalAmmVolumeUsd_lte: String
  totalAmmVolumeUsd_in: [String!]
  totalAmmVolumeUsd_not_in: [String!]
  totalAmmLpFeesUsd: String
  totalAmmLpFeesUsd_not: String
  totalAmmLpFeesUsd_gt: String
  totalAmmLpFeesUsd_lt: String
  totalAmmLpFeesUsd_gte: String
  totalAmmLpFeesUsd_lte: String
  totalAmmLpFeesUsd_in: [String!]
  totalAmmLpFeesUsd_not_in: [String!]
  totalAmmStakerFeesUsd: String
  totalAmmStakerFeesUsd_not: String
  totalAmmStakerFeesUsd_gt: String
  totalAmmStakerFeesUsd_lt: String
  totalAmmStakerFeesUsd_gte: String
  totalAmmStakerFeesUsd_lte: String
  totalAmmStakerFeesUsd_in: [String!]
  totalAmmStakerFeesUsd_not_in: [String!]
  totalTradingFeesUsd: String
  totalTradingFeesUsd_not: String
  totalTradingFeesUsd_gt: String
  totalTradingFeesUsd_lt: String
  totalTradingFeesUsd_gte: String
  totalTradingFeesUsd_lte: String
  totalTradingFeesUsd_in: [String!]
  totalTradingFeesUsd_not_in: [String!]
  totalLendingFeesUsd: String
  totalLendingFeesUsd_not: String
  totalLendingFeesUsd_gt: String
  totalLendingFeesUsd_lt: String
  totalLendingFeesUsd_gte: String
  totalLendingFeesUsd_lte: String
  totalLendingFeesUsd_in: [String!]
  totalLendingFeesUsd_not_in: [String!]
  totalBorrowingFeesUsd: String
  totalBorrowingFeesUsd_not: String
  totalBorrowingFeesUsd_gt: String
  totalBorrowingFeesUsd_lt: String
  totalBorrowingFeesUsd_gte: String
  totalBorrowingFeesUsd_lte: String
  totalBorrowingFeesUsd_in: [String!]
  totalBorrowingFeesUsd_not_in: [String!]
  totalLendVolumeUsd: String
  totalLendVolumeUsd_not: String
  totalLendVolumeUsd_gt: String
  totalLendVolumeUsd_lt: String
  totalLendVolumeUsd_gte: String
  totalLendVolumeUsd_lte: String
  totalLendVolumeUsd_in: [String!]
  totalLendVolumeUsd_not_in: [String!]
  totalUnlendVolumeUsd: String
  totalUnlendVolumeUsd_not: String
  totalUnlendVolumeUsd_gt: String
  totalUnlendVolumeUsd_lt: String
  totalUnlendVolumeUsd_gte: String
  totalUnlendVolumeUsd_lte: String
  totalUnlendVolumeUsd_in: [String!]
  totalUnlendVolumeUsd_not_in: [String!]
  totalBorrowVolumeUsd: String
  totalBorrowVolumeUsd_not: String
  totalBorrowVolumeUsd_gt: String
  totalBorrowVolumeUsd_lt: String
  totalBorrowVolumeUsd_gte: String
  totalBorrowVolumeUsd_lte: String
  totalBorrowVolumeUsd_in: [String!]
  totalBorrowVolumeUsd_not_in: [String!]
  totalCloseWithDepositVolumeUsd: String
  totalCloseWithDepositVolumeUsd_not: String
  totalCloseWithDepositVolumeUsd_gt: String
  totalCloseWithDepositVolumeUsd_lt: String
  totalCloseWithDepositVolumeUsd_gte: String
  totalCloseWithDepositVolumeUsd_lte: String
  totalCloseWithDepositVolumeUsd_in: [String!]
  totalCloseWithDepositVolumeUsd_not_in: [String!]
  currentVoluntarilyStakedSov: String
  currentVoluntarilyStakedSov_not: String
  currentVoluntarilyStakedSov_gt: String
  currentVoluntarilyStakedSov_lt: String
  currentVoluntarilyStakedSov_gte: String
  currentVoluntarilyStakedSov_lte: String
  currentVoluntarilyStakedSov_in: [String!]
  currentVoluntarilyStakedSov_not_in: [String!]
  currentStakedByVestingSov: String
  currentStakedByVestingSov_not: String
  currentStakedByVestingSov_gt: String
  currentStakedByVestingSov_lt: String
  currentStakedByVestingSov_gte: String
  currentStakedByVestingSov_lte: String
  currentStakedByVestingSov_in: [String!]
  currentStakedByVestingSov_not_in: [String!]
}
input RewardsEarnedHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  action: RewardsEarnedAction
  action_not: RewardsEarnedAction
  action_in: [RewardsEarnedAction!]
  action_not_in: [RewardsEarnedAction!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input Rollover_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  lender: String
  lender_not: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  principal: String
  principal_not: String
  principal_gt: String
  principal_lt: String
  principal_gte: String
  principal_lte: String
  principal_in: [String!]
  principal_not_in: [String!]
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  endTimestamp: Int
  endTimestamp_not: Int
  endTimestamp_gt: Int
  endTimestamp_lt: Int
  endTimestamp_gte: Int
  endTimestamp_lte: Int
  endTimestamp_in: [Int!]
  endTimestamp_not_in: [Int!]
  rewardReceiver: String
  rewardReceiver_not: String
  rewardReceiver_gt: String
  rewardReceiver_lt: String
  rewardReceiver_gte: String
  rewardReceiver_lte: String
  rewardReceiver_in: [String!]
  rewardReceiver_not_in: [String!]
  rewardReceiver_contains: String
  rewardReceiver_not_contains: String
  rewardReceiver_starts_with: String
  rewardReceiver_not_starts_with: String
  rewardReceiver_ends_with: String
  rewardReceiver_not_ends_with: String
  reward: String
  reward_not: String
  reward_gt: String
  reward_lt: String
  reward_gte: String
  reward_lte: String
  reward_in: [String!]
  reward_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input SideToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  originalTokenAddress: String
  originalTokenAddress_not: String
  originalTokenAddress_in: [String!]
  originalTokenAddress_not_in: [String!]
  originalTokenAddress_contains: String
  originalTokenAddress_not_contains: String
  sideTokenAddress: String
  sideTokenAddress_not: String
  sideTokenAddress_in: [String!]
  sideTokenAddress_not_in: [String!]
  sideTokenAddress_contains: String
  sideTokenAddress_not_contains: String
  newSymbol: String
  newSymbol_not: String
  newSymbol_gt: String
  newSymbol_lt: String
  newSymbol_gte: String
  newSymbol_lte: String
  newSymbol_in: [String!]
  newSymbol_not_in: [String!]
  newSymbol_contains: String
  newSymbol_not_contains: String
  newSymbol_starts_with: String
  newSymbol_not_starts_with: String
  newSymbol_ends_with: String
  newSymbol_not_ends_with: String
  granularity: String
  granularity_not: String
  granularity_gt: String
  granularity_lt: String
  granularity_gte: String
  granularity_lte: String
  granularity_in: [String!]
  granularity_not_in: [String!]
  createdAtTx: String
  createdAtTx_not: String
  createdAtTx_gt: String
  createdAtTx_lt: String
  createdAtTx_gte: String
  createdAtTx_lte: String
  createdAtTx_in: [String!]
  createdAtTx_not_in: [String!]
  createdAtTx_contains: String
  createdAtTx_not_contains: String
  createdAtTx_starts_with: String
  createdAtTx_not_starts_with: String
  createdAtTx_ends_with: String
  createdAtTx_not_ends_with: String
  updatedAtTx: String
  updatedAtTx_not: String
  updatedAtTx_gt: String
  updatedAtTx_lt: String
  updatedAtTx_gte: String
  updatedAtTx_lte: String
  updatedAtTx_in: [String!]
  updatedAtTx_not_in: [String!]
  updatedAtTx_contains: String
  updatedAtTx_not_contains: String
  updatedAtTx_starts_with: String
  updatedAtTx_not_starts_with: String
  updatedAtTx_ends_with: String
  updatedAtTx_not_ends_with: String
}
input SmartToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  smartTokenType: String
  smartTokenType_not: String
  smartTokenType_gt: String
  smartTokenType_lt: String
  smartTokenType_gte: String
  smartTokenType_lte: String
  smartTokenType_in: [String!]
  smartTokenType_not_in: [String!]
  smartTokenType_contains: String
  smartTokenType_not_contains: String
  smartTokenType_starts_with: String
  smartTokenType_not_starts_with: String
  smartTokenType_ends_with: String
  smartTokenType_not_ends_with: String
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_not_contains: String
  owner_starts_with: String
  owner_not_starts_with: String
  owner_ends_with: String
  owner_not_ends_with: String
  currentConverterRegistry: String
  currentConverterRegistry_not: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_lt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_contains: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_not_ends_with: String
  addedToRegistryBlockNumber: Int
  addedToRegistryBlockNumber_not: Int
  addedToRegistryBlockNumber_gt: Int
  addedToRegistryBlockNumber_lt: Int
  addedToRegistryBlockNumber_gte: Int
  addedToRegistryBlockNumber_lte: Int
  addedToRegistryBlockNumber_in: [Int!]
  addedToRegistryBlockNumber_not_in: [Int!]
  addedToRegistryTransactionHash: String
  addedToRegistryTransactionHash_not: String
  addedToRegistryTransactionHash_in: [String!]
  addedToRegistryTransactionHash_not_in: [String!]
  addedToRegistryTransactionHash_contains: String
  addedToRegistryTransactionHash_not_contains: String
}
input StakeHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  action: StakeHistoryAction
  action_not: StakeHistoryAction
  action_in: [StakeHistoryAction!]
  action_not_in: [StakeHistoryAction!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  lockedUntil: Int
  lockedUntil_not: Int
  lockedUntil_gt: Int
  lockedUntil_lt: Int
  lockedUntil_gte: Int
  lockedUntil_lte: Int
  lockedUntil_in: [Int!]
  lockedUntil_not_in: [Int!]
}
input Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  numConversions: Int
  numConversions_not: Int
  numConversions_gt: Int
  numConversions_lt: Int
  numConversions_gte: Int
  numConversions_lte: Int
  numConversions_in: [Int!]
  numConversions_not_in: [Int!]
  fromToken: String
  fromToken_not: String
  fromToken_gt: String
  fromToken_lt: String
  fromToken_gte: String
  fromToken_lte: String
  fromToken_in: [String!]
  fromToken_not_in: [String!]
  fromToken_contains: String
  fromToken_not_contains: String
  fromToken_starts_with: String
  fromToken_not_starts_with: String
  fromToken_ends_with: String
  fromToken_not_ends_with: String
  toToken: String
  toToken_not: String
  toToken_gt: String
  toToken_lt: String
  toToken_gte: String
  toToken_lte: String
  toToken_in: [String!]
  toToken_not_in: [String!]
  toToken_contains: String
  toToken_not_contains: String
  toToken_starts_with: String
  toToken_not_starts_with: String
  toToken_ends_with: String
  toToken_not_ends_with: String
  fromAmount: String
  fromAmount_not: String
  fromAmount_gt: String
  fromAmount_lt: String
  fromAmount_gte: String
  fromAmount_lte: String
  fromAmount_in: [String!]
  fromAmount_not_in: [String!]
  toAmount: String
  toAmount_not: String
  toAmount_gt: String
  toAmount_lt: String
  toAmount_gte: String
  toAmount_lte: String
  toAmount_in: [String!]
  toAmount_not_in: [String!]
  rate: String
  rate_not: String
  rate_gt: String
  rate_lt: String
  rate_gte: String
  rate_lte: String
  rate_in: [String!]
  rate_not_in: [String!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  isMarginTrade: Boolean
  isMarginTrade_not: Boolean
  isMarginTrade_in: [Boolean!]
  isMarginTrade_not_in: [Boolean!]
  isBorrow: Boolean
  isBorrow_not: Boolean
  isBorrow_in: [Boolean!]
  isBorrow_not_in: [Boolean!]
  isLimit: Boolean
  isLimit_not: Boolean
  isLimit_in: [Boolean!]
  isLimit_not_in: [Boolean!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input TokenSmartToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  smartToken: String
  smartToken_not: String
  smartToken_gt: String
  smartToken_lt: String
  smartToken_gte: String
  smartToken_lte: String
  smartToken_in: [String!]
  smartToken_not_in: [String!]
  smartToken_contains: String
  smartToken_not_contains: String
  smartToken_starts_with: String
  smartToken_not_starts_with: String
  smartToken_ends_with: String
  smartToken_not_ends_with: String
}
input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  version: Int
  version_not: Int
  version_gt: Int
  version_lt: Int
  version_gte: Int
  version_lte: Int
  version_in: [Int!]
  version_not_in: [Int!]
  prevPriceBtc: String
  prevPriceBtc_not: String
  prevPriceBtc_gt: String
  prevPriceBtc_lt: String
  prevPriceBtc_gte: String
  prevPriceBtc_lte: String
  prevPriceBtc_in: [String!]
  prevPriceBtc_not_in: [String!]
  lastPriceBtc: String
  lastPriceBtc_not: String
  lastPriceBtc_gt: String
  lastPriceBtc_lt: String
  lastPriceBtc_gte: String
  lastPriceBtc_lte: String
  lastPriceBtc_in: [String!]
  lastPriceBtc_not_in: [String!]
  prevPriceUsd: String
  prevPriceUsd_not: String
  prevPriceUsd_gt: String
  prevPriceUsd_lt: String
  prevPriceUsd_gte: String
  prevPriceUsd_lte: String
  prevPriceUsd_in: [String!]
  prevPriceUsd_not_in: [String!]
  lastPriceUsd: String
  lastPriceUsd_not: String
  lastPriceUsd_gt: String
  lastPriceUsd_lt: String
  lastPriceUsd_gte: String
  lastPriceUsd_lte: String
  lastPriceUsd_in: [String!]
  lastPriceUsd_not_in: [String!]
  btcVolume: String
  btcVolume_not: String
  btcVolume_gt: String
  btcVolume_lt: String
  btcVolume_gte: String
  btcVolume_lte: String
  btcVolume_in: [String!]
  btcVolume_not_in: [String!]
  usdVolume: String
  usdVolume_not: String
  usdVolume_gt: String
  usdVolume_lt: String
  usdVolume_gte: String
  usdVolume_lte: String
  usdVolume_in: [String!]
  usdVolume_not_in: [String!]
  tokenVolume: String
  tokenVolume_not: String
  tokenVolume_gt: String
  tokenVolume_lt: String
  tokenVolume_gte: String
  tokenVolume_lte: String
  tokenVolume_in: [String!]
  tokenVolume_not_in: [String!]
  currentConverterRegistry: String
  currentConverterRegistry_not: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_lt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_contains: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_not_ends_with: String
  hasBtcPool: Boolean
  hasBtcPool_not: Boolean
  hasBtcPool_in: [Boolean!]
  hasBtcPool_not_in: [Boolean!]
  hasStablecoinPool: Boolean
  hasStablecoinPool_not: Boolean
  hasStablecoinPool_in: [Boolean!]
  hasStablecoinPool_not_in: [Boolean!]
}
input TokensStaked_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  staker: String
  staker_not: String
  staker_in: [String!]
  staker_not_in: [String!]
  staker_contains: String
  staker_not_contains: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  lockedUntil: Int
  lockedUntil_not: Int
  lockedUntil_gt: Int
  lockedUntil_lt: Int
  lockedUntil_gte: Int
  lockedUntil_lte: Int
  lockedUntil_in: [Int!]
  lockedUntil_not_in: [Int!]
  totalStaked: String
  totalStaked_not: String
  totalStaked_gt: String
  totalStaked_lt: String
  totalStaked_gte: String
  totalStaked_lte: String
  totalStaked_in: [String!]
  totalStaked_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  isUserStaked: Boolean
  isUserStaked_not: Boolean
  isUserStaked_in: [Boolean!]
  isUserStaked_not_in: [Boolean!]
}
input Trade_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  lender: String
  lender_not: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_gt: String
  collateralToken_lt: String
  collateralToken_gte: String
  collateralToken_lte: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_not_contains: String
  collateralToken_starts_with: String
  collateralToken_not_starts_with: String
  collateralToken_ends_with: String
  collateralToken_not_ends_with: String
  loanToken: String
  loanToken_not: String
  loanToken_gt: String
  loanToken_lt: String
  loanToken_gte: String
  loanToken_lte: String
  loanToken_in: [String!]
  loanToken_not_in: [String!]
  loanToken_contains: String
  loanToken_not_contains: String
  loanToken_starts_with: String
  loanToken_not_starts_with: String
  loanToken_ends_with: String
  loanToken_not_ends_with: String
  positionSize: String
  positionSize_not: String
  positionSize_gt: String
  positionSize_lt: String
  positionSize_gte: String
  positionSize_lte: String
  positionSize_in: [String!]
  positionSize_not_in: [String!]
  borrowedAmount: String
  borrowedAmount_not: String
  borrowedAmount_gt: String
  borrowedAmount_lt: String
  borrowedAmount_gte: String
  borrowedAmount_lte: String
  borrowedAmount_in: [String!]
  borrowedAmount_not_in: [String!]
  interestRate: String
  interestRate_not: String
  interestRate_gt: String
  interestRate_lt: String
  interestRate_gte: String
  interestRate_lte: String
  interestRate_in: [String!]
  interestRate_not_in: [String!]
  settlementDate: Int
  settlementDate_not: Int
  settlementDate_gt: Int
  settlementDate_lt: Int
  settlementDate_gte: Int
  settlementDate_lte: Int
  settlementDate_in: [Int!]
  settlementDate_not_in: [Int!]
  entryPrice: String
  entryPrice_not: String
  entryPrice_gt: String
  entryPrice_lt: String
  entryPrice_gte: String
  entryPrice_lte: String
  entryPrice_in: [String!]
  entryPrice_not_in: [String!]
  entryLeverage: String
  entryLeverage_not: String
  entryLeverage_gt: String
  entryLeverage_lt: String
  entryLeverage_gte: String
  entryLeverage_lte: String
  entryLeverage_in: [String!]
  entryLeverage_not_in: [String!]
  currentLeverage: String
  currentLeverage_not: String
  currentLeverage_gt: String
  currentLeverage_lt: String
  currentLeverage_gte: String
  currentLeverage_lte: String
  currentLeverage_in: [String!]
  currentLeverage_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  gasPrice: String
  gasPrice_not: String
  gasPrice_gt: String
  gasPrice_lt: String
  gasPrice_gte: String
  gasPrice_lte: String
  gasPrice_in: [String!]
  gasPrice_not_in: [String!]
  index: Int
  index_not: Int
  index_gt: Int
  index_lt: Int
  index_gte: Int
  index_lte: Int
  index_in: [Int!]
  index_not_in: [Int!]
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_not_contains: String
  from_starts_with: String
  from_not_starts_with: String
  from_ends_with: String
  from_not_ends_with: String
  to: String
  to_not: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_not_contains: String
  value: String
  value_not: String
  value_gt: String
  value_lt: String
  value_gte: String
  value_lte: String
  value_in: [String!]
  value_not_in: [String!]
  gasLimit: String
  gasLimit_not: String
  gasLimit_gt: String
  gasLimit_lt: String
  gasLimit_gte: String
  gasLimit_lte: String
  gasLimit_in: [String!]
  gasLimit_not_in: [String!]
}
input UserLendingHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  lendingPool: String
  lendingPool_not: String
  lendingPool_gt: String
  lendingPool_lt: String
  lendingPool_gte: String
  lendingPool_lte: String
  lendingPool_in: [String!]
  lendingPool_not_in: [String!]
  lendingPool_contains: String
  lendingPool_not_contains: String
  lendingPool_starts_with: String
  lendingPool_not_starts_with: String
  lendingPool_ends_with: String
  lendingPool_not_ends_with: String
  totalLendVolume: String
  totalLendVolume_not: String
  totalLendVolume_gt: String
  totalLendVolume_lt: String
  totalLendVolume_gte: String
  totalLendVolume_lte: String
  totalLendVolume_in: [String!]
  totalLendVolume_not_in: [String!]
  totalUnlendVolume: String
  totalUnlendVolume_not: String
  totalUnlendVolume_gt: String
  totalUnlendVolume_lt: String
  totalUnlendVolume_gte: String
  totalUnlendVolume_lte: String
  totalUnlendVolume_in: [String!]
  totalUnlendVolume_not_in: [String!]
}
input UserLiquidityHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  poolToken: String
  poolToken_not: String
  poolToken_gt: String
  poolToken_lt: String
  poolToken_gte: String
  poolToken_lte: String
  poolToken_in: [String!]
  poolToken_not_in: [String!]
  poolToken_contains: String
  poolToken_not_contains: String
  poolToken_starts_with: String
  poolToken_not_starts_with: String
  poolToken_ends_with: String
  poolToken_not_ends_with: String
  totalAsset0LiquidityAdded: String
  totalAsset0LiquidityAdded_not: String
  totalAsset0LiquidityAdded_gt: String
  totalAsset0LiquidityAdded_lt: String
  totalAsset0LiquidityAdded_gte: String
  totalAsset0LiquidityAdded_lte: String
  totalAsset0LiquidityAdded_in: [String!]
  totalAsset0LiquidityAdded_not_in: [String!]
  totalAsset0LiquidityRemoved: String
  totalAsset0LiquidityRemoved_not: String
  totalAsset0LiquidityRemoved_gt: String
  totalAsset0LiquidityRemoved_lt: String
  totalAsset0LiquidityRemoved_gte: String
  totalAsset0LiquidityRemoved_lte: String
  totalAsset0LiquidityRemoved_in: [String!]
  totalAsset0LiquidityRemoved_not_in: [String!]
  totalAsset1LiquidityAdded: String
  totalAsset1LiquidityAdded_not: String
  totalAsset1LiquidityAdded_gt: String
  totalAsset1LiquidityAdded_lt: String
  totalAsset1LiquidityAdded_gte: String
  totalAsset1LiquidityAdded_lte: String
  totalAsset1LiquidityAdded_in: [String!]
  totalAsset1LiquidityAdded_not_in: [String!]
  totalAsset1LiquidityRemoved: String
  totalAsset1LiquidityRemoved_not: String
  totalAsset1LiquidityRemoved_gt: String
  totalAsset1LiquidityRemoved_lt: String
  totalAsset1LiquidityRemoved_gte: String
  totalAsset1LiquidityRemoved_lte: String
  totalAsset1LiquidityRemoved_in: [String!]
  totalAsset1LiquidityRemoved_not_in: [String!]
}
input UserRewardsEarnedHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalFeesAndRewardsEarned: String
  totalFeesAndRewardsEarned_not: String
  totalFeesAndRewardsEarned_gt: String
  totalFeesAndRewardsEarned_lt: String
  totalFeesAndRewardsEarned_gte: String
  totalFeesAndRewardsEarned_lte: String
  totalFeesAndRewardsEarned_in: [String!]
  totalFeesAndRewardsEarned_not_in: [String!]
  availableTradingRewards: String
  availableTradingRewards_not: String
  availableTradingRewards_gt: String
  availableTradingRewards_lt: String
  availableTradingRewards_gte: String
  availableTradingRewards_lte: String
  availableTradingRewards_in: [String!]
  availableTradingRewards_not_in: [String!]
  totalTradingRewards: String
  totalTradingRewards_not: String
  totalTradingRewards_gt: String
  totalTradingRewards_lt: String
  totalTradingRewards_gte: String
  totalTradingRewards_lte: String
  totalTradingRewards_in: [String!]
  totalTradingRewards_not_in: [String!]
  totalLendingRewards: String
  totalLendingRewards_not: String
  totalLendingRewards_gt: String
  totalLendingRewards_lt: String
  totalLendingRewards_gte: String
  totalLendingRewards_lte: String
  totalLendingRewards_in: [String!]
  totalLendingRewards_not_in: [String!]
  totalLiquidityRewards: String
  totalLiquidityRewards_not: String
  totalLiquidityRewards_gt: String
  totalLiquidityRewards_lt: String
  totalLiquidityRewards_gte: String
  totalLiquidityRewards_lte: String
  totalLiquidityRewards_in: [String!]
  totalLiquidityRewards_not_in: [String!]
  totalStakingRewards: String
  totalStakingRewards_not: String
  totalStakingRewards_gt: String
  totalStakingRewards_lt: String
  totalStakingRewards_gte: String
  totalStakingRewards_lte: String
  totalStakingRewards_in: [String!]
  totalStakingRewards_not_in: [String!]
  totalFeeWithdrawn: String
  totalFeeWithdrawn_not: String
  totalFeeWithdrawn_gt: String
  totalFeeWithdrawn_lt: String
  totalFeeWithdrawn_gte: String
  totalFeeWithdrawn_lte: String
  totalFeeWithdrawn_in: [String!]
  totalFeeWithdrawn_not_in: [String!]
}
input UserStakeHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalStaked: String
  totalStaked_not: String
  totalStaked_gt: String
  totalStaked_lt: String
  totalStaked_gte: String
  totalStaked_lte: String
  totalStaked_in: [String!]
  totalStaked_not_in: [String!]
  totalWithdrawn: String
  totalWithdrawn_not: String
  totalWithdrawn_gt: String
  totalWithdrawn_lt: String
  totalWithdrawn_gte: String
  totalWithdrawn_lte: String
  totalWithdrawn_in: [String!]
  totalWithdrawn_not_in: [String!]
  totalRemaining: String
  totalRemaining_not: String
  totalRemaining_gt: String
  totalRemaining_lt: String
  totalRemaining_gte: String
  totalRemaining_lte: String
  totalRemaining_in: [String!]
  totalRemaining_not_in: [String!]
}
input UserTotal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalMarginTradeVolumeUsd: String
  totalMarginTradeVolumeUsd_not: String
  totalMarginTradeVolumeUsd_gt: String
  totalMarginTradeVolumeUsd_lt: String
  totalMarginTradeVolumeUsd_gte: String
  totalMarginTradeVolumeUsd_lte: String
  totalMarginTradeVolumeUsd_in: [String!]
  totalMarginTradeVolumeUsd_not_in: [String!]
  totalCloseWithSwapVolumeUsd: String
  totalCloseWithSwapVolumeUsd_not: String
  totalCloseWithSwapVolumeUsd_gt: String
  totalCloseWithSwapVolumeUsd_lt: String
  totalCloseWithSwapVolumeUsd_gte: String
  totalCloseWithSwapVolumeUsd_lte: String
  totalCloseWithSwapVolumeUsd_in: [String!]
  totalCloseWithSwapVolumeUsd_not_in: [String!]
  totalDepositCollateralVolumeUsd: String
  totalDepositCollateralVolumeUsd_not: String
  totalDepositCollateralVolumeUsd_gt: String
  totalDepositCollateralVolumeUsd_lt: String
  totalDepositCollateralVolumeUsd_gte: String
  totalDepositCollateralVolumeUsd_lte: String
  totalDepositCollateralVolumeUsd_in: [String!]
  totalDepositCollateralVolumeUsd_not_in: [String!]
  totalLiquidateVolumeUsd: String
  totalLiquidateVolumeUsd_not: String
  totalLiquidateVolumeUsd_gt: String
  totalLiquidateVolumeUsd_lt: String
  totalLiquidateVolumeUsd_gte: String
  totalLiquidateVolumeUsd_lte: String
  totalLiquidateVolumeUsd_in: [String!]
  totalLiquidateVolumeUsd_not_in: [String!]
  totalAmmVolumeUsd: String
  totalAmmVolumeUsd_not: String
  totalAmmVolumeUsd_gt: String
  totalAmmVolumeUsd_lt: String
  totalAmmVolumeUsd_gte: String
  totalAmmVolumeUsd_lte: String
  totalAmmVolumeUsd_in: [String!]
  totalAmmVolumeUsd_not_in: [String!]
  totalAmmLpFeesUsd: String
  totalAmmLpFeesUsd_not: String
  totalAmmLpFeesUsd_gt: String
  totalAmmLpFeesUsd_lt: String
  totalAmmLpFeesUsd_gte: String
  totalAmmLpFeesUsd_lte: String
  totalAmmLpFeesUsd_in: [String!]
  totalAmmLpFeesUsd_not_in: [String!]
  totalAmmStakerFeesUsd: String
  totalAmmStakerFeesUsd_not: String
  totalAmmStakerFeesUsd_gt: String
  totalAmmStakerFeesUsd_lt: String
  totalAmmStakerFeesUsd_gte: String
  totalAmmStakerFeesUsd_lte: String
  totalAmmStakerFeesUsd_in: [String!]
  totalAmmStakerFeesUsd_not_in: [String!]
  totalTradingFeesUsd: String
  totalTradingFeesUsd_not: String
  totalTradingFeesUsd_gt: String
  totalTradingFeesUsd_lt: String
  totalTradingFeesUsd_gte: String
  totalTradingFeesUsd_lte: String
  totalTradingFeesUsd_in: [String!]
  totalTradingFeesUsd_not_in: [String!]
  totalLendingFeesUsd: String
  totalLendingFeesUsd_not: String
  totalLendingFeesUsd_gt: String
  totalLendingFeesUsd_lt: String
  totalLendingFeesUsd_gte: String
  totalLendingFeesUsd_lte: String
  totalLendingFeesUsd_in: [String!]
  totalLendingFeesUsd_not_in: [String!]
  totalBorrowingFeesUsd: String
  totalBorrowingFeesUsd_not: String
  totalBorrowingFeesUsd_gt: String
  totalBorrowingFeesUsd_lt: String
  totalBorrowingFeesUsd_gte: String
  totalBorrowingFeesUsd_lte: String
  totalBorrowingFeesUsd_in: [String!]
  totalBorrowingFeesUsd_not_in: [String!]
  totalLendVolumeUsd: String
  totalLendVolumeUsd_not: String
  totalLendVolumeUsd_gt: String
  totalLendVolumeUsd_lt: String
  totalLendVolumeUsd_gte: String
  totalLendVolumeUsd_lte: String
  totalLendVolumeUsd_in: [String!]
  totalLendVolumeUsd_not_in: [String!]
  totalUnlendVolumeUsd: String
  totalUnlendVolumeUsd_not: String
  totalUnlendVolumeUsd_gt: String
  totalUnlendVolumeUsd_lt: String
  totalUnlendVolumeUsd_gte: String
  totalUnlendVolumeUsd_lte: String
  totalUnlendVolumeUsd_in: [String!]
  totalUnlendVolumeUsd_not_in: [String!]
  totalBorrowVolumeUsd: String
  totalBorrowVolumeUsd_not: String
  totalBorrowVolumeUsd_gt: String
  totalBorrowVolumeUsd_lt: String
  totalBorrowVolumeUsd_gte: String
  totalBorrowVolumeUsd_lte: String
  totalBorrowVolumeUsd_in: [String!]
  totalBorrowVolumeUsd_not_in: [String!]
  totalCloseWithDepositVolumeUsd: String
  totalCloseWithDepositVolumeUsd_not: String
  totalCloseWithDepositVolumeUsd_gt: String
  totalCloseWithDepositVolumeUsd_lt: String
  totalCloseWithDepositVolumeUsd_gte: String
  totalCloseWithDepositVolumeUsd_lte: String
  totalCloseWithDepositVolumeUsd_in: [String!]
  totalCloseWithDepositVolumeUsd_not_in: [String!]
}
input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_lt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_not_in: [Int!]
}
input VestingContract_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  createdAtTimestamp: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_lt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_not_in: [Int!]
  cliff: Int
  cliff_not: Int
  cliff_gt: Int
  cliff_lt: Int
  cliff_gte: Int
  cliff_lte: Int
  cliff_in: [Int!]
  cliff_not_in: [Int!]
  duration: Int
  duration_not: Int
  duration_gt: Int
  duration_lt: Int
  duration_gte: Int
  duration_lte: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  startingBalance: String
  startingBalance_not: String
  startingBalance_gt: String
  startingBalance_lt: String
  startingBalance_gte: String
  startingBalance_lte: String
  startingBalance_in: [String!]
  startingBalance_not_in: [String!]
  currentBalance: String
  currentBalance_not: String
  currentBalance_gt: String
  currentBalance_lt: String
  currentBalance_gte: String
  currentBalance_lte: String
  currentBalance_in: [String!]
  currentBalance_not_in: [String!]
  type: VestingContractType
  type_not: VestingContractType
  type_in: [VestingContractType!]
  type_not_in: [VestingContractType!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  createdAtTransaction: String
  createdAtTransaction_not: String
  createdAtTransaction_gt: String
  createdAtTransaction_lt: String
  createdAtTransaction_gte: String
  createdAtTransaction_lte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_contains: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_starts_with: String
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_not_ends_with: String
}
input VestingHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  action: VestingHistoryItemAction
  action_not: VestingHistoryItemAction
  action_in: [VestingHistoryItemAction!]
  action_not_in: [VestingHistoryItemAction!]
  staker: String
  staker_not: String
  staker_gt: String
  staker_lt: String
  staker_gte: String
  staker_lte: String
  staker_in: [String!]
  staker_not_in: [String!]
  staker_contains: String
  staker_not_contains: String
  staker_starts_with: String
  staker_not_starts_with: String
  staker_ends_with: String
  staker_not_ends_with: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  lockedUntil: Int
  lockedUntil_not: Int
  lockedUntil_gt: Int
  lockedUntil_lt: Int
  lockedUntil_gte: Int
  lockedUntil_lte: Int
  lockedUntil_in: [Int!]
  lockedUntil_not_in: [Int!]
  totalStaked: String
  totalStaked_not: String
  totalStaked_gt: String
  totalStaked_lt: String
  totalStaked_gte: String
  totalStaked_lte: String
  totalStaked_in: [String!]
  totalStaked_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input VoteCast_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  voter: String
  voter_not: String
  voter_gt: String
  voter_lt: String
  voter_gte: String
  voter_lte: String
  voter_in: [String!]
  voter_not_in: [String!]
  voter_contains: String
  voter_not_contains: String
  voter_starts_with: String
  voter_not_starts_with: String
  voter_ends_with: String
  voter_not_ends_with: String
  proposalId: Int
  proposalId_not: Int
  proposalId_gt: Int
  proposalId_lt: Int
  proposalId_gte: Int
  proposalId_lte: Int
  proposalId_in: [Int!]
  proposalId_not_in: [Int!]
  proposal: String
  proposal_not: String
  proposal_gt: String
  proposal_lt: String
  proposal_gte: String
  proposal_lte: String
  proposal_in: [String!]
  proposal_not_in: [String!]
  proposal_contains: String
  proposal_not_contains: String
  proposal_starts_with: String
  proposal_not_starts_with: String
  proposal_ends_with: String
  proposal_not_ends_with: String
  support: Boolean
  support_not: Boolean
  support_in: [Boolean!]
  support_not_in: [Boolean!]
  votes: String
  votes_not: String
  votes_gt: String
  votes_lt: String
  votes_gte: String
  votes_lte: String
  votes_in: [String!]
  votes_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
input Withdrawal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  receiver: String
  receiver_not: String
  receiver_in: [String!]
  receiver_not_in: [String!]
  receiver_contains: String
  receiver_not_contains: String
  amount: String
  amount_not: String
  amount_gt: String
  amount_lt: String
  amount_gte: String
  amount_lte: String
  amount_in: [String!]
  amount_not_in: [String!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  emittedBy: String
  emittedBy_not: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}
directive @entity on OBJECT
directive @derivedFrom(field: String) on FIELD_DEFINITION
directive @subgraphId(id: String) on OBJECT
