type AcceptedCrossTransfer @entity {
  id: ID!
  _tokenAddress: Bytes! # address
  _to: Bytes! # address
  _amount: BigInt! # uint256
  _decimals: Int! # uint8
  _granularity: BigInt! # uint256
  _formattedAmount: BigInt! # uint256
  _calculatedDecimals: Int! # uint8
  _calculatedGranularity: BigInt! # uint256
  _userData: Bytes! # bytes
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type AllowTokenChanged @entity {
  id: ID!
  _newAllowToken: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type BridgeReceiverStatusChanged @entity {
  id: ID!
  bridgeReceiver: Bytes! # address
  newStatus: Boolean! # bool
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Cross @entity {
  id: ID!
  _tokenAddress: Bytes! # address
  _to: Bytes! # address
  _amount: BigInt! # uint256
  _symbol: String! # string
  _userData: Bytes! # bytes
  _decimals: Int! # uint8
  _granularity: BigInt! # uint256
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ErrorTokenReceiver @entity {
  id: ID!
  _errorData: Bytes! # bytes
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type FederationChanged @entity {
  id: ID!
  _newFederation: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type NewSideToken @entity {
  id: ID!
  _newSideTokenAddress: Bytes! # address
  _originalTokenAddress: Bytes! # address
  _newSymbol: String! # string
  _granularity: BigInt! # uint256
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type OwnershipTransferred @entity {
  id: ID!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Paused @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PauserAdded @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PauserRemoved @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PrefixUpdated @entity {
  id: ID!
  _isSuffix: Boolean! # bool
  _prefix: String! # string
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type RevokeTx @entity {
  id: ID!
  tx_revoked: Bytes! # bytes32
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SideTokenFactoryChanged @entity {
  id: ID!
  _newSideTokenFactory: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Unpaused @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Upgrading @entity {
  id: ID!
  isUpgrading: Boolean! # bool
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type erc777ConverterSet @entity {
  id: ID!
  erc777ConverterAddress: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

enum BridgeType {
  RSK_BSC
  RSK_ETH
}

type Bridge @entity {
  id: ID! # Bridge address
  type: BridgeType! # BridgeType
  # owner: Bytes
  prefix: String
  isSuffix: Boolean
  federation: Federation!
  isUpgrading: Boolean! # boolean
  isPaused: Boolean! # boolean
  totalFundsSent: BigInt! # uint256
  totalFundsReceived: BigInt! # uint256
  feesCollected: BigInt! # uint256
  pausers: [Bytes!]! # address[]
  createdAtTx: Transaction! # Transaction
  updatedAtTx: Transaction! # Transaction
}

enum CrossDirection {
  Incoming
  Outgoing
}

enum CrossStatus {
  Voting
  Executed
  Revoked
}

enum BridgeChain {
  RSK
  ETH
  BSC
}

type CrossTransfer @entity {
  id: ID! # TransactionIdU
  direction: CrossDirection! # CrossDirection
  sourceChain: BridgeChain!
  destinationChain: BridgeChain!
  votes: Int # uint8
  status: CrossStatus! # CrossStatus
  originalTokenAddress: Bytes!
  tokenAddress: Bytes # address
  token: Token # Token
  sideToken: SideToken # SideToken
  receiver: User # address
  sender: User
  amount: BigDecimal!
  symbol: String # string
  sourceChainBlockHash: Bytes # bytes
  sourceChainTransactionHash: Bytes # bytes
  createdAtTx: Transaction! # Transaction
  createdAtTimestamp: Int!
  updatedAtTx: Transaction! # Transaction
  updatedAtTimestamp: Int!
}

type SideToken @entity {
  id: ID!
  originalTokenAddress: Bytes!
  sideTokenAddress: Bytes!
  newSymbol: String!
  granularity: BigInt!
  createdAtTx: Transaction! # Transaction
  updatedAtTx: Transaction! # Transaction
}
