type AcceptedCrossTransfer @entity {
  id: ID!
  _tokenAddress: Bytes! # address
  _to: Bytes! # address
  _amount: BigInt! # uint256
  _decimals: Int! # uint8
  _granularity: BigInt! # uint256
  _formattedAmount: BigInt! # uint256
  _calculatedDecimals: Int! # uint8
  _calculatedGranularity: BigInt! # uint256
  _userData: Bytes! # bytes
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type AllowTokenChanged @entity {
  id: ID!
  _newAllowToken: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type BridgeReceiverStatusChanged @entity {
  id: ID!
  bridgeReceiver: Bytes! # address
  newStatus: Boolean! # bool
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Cross @entity {
  id: ID!
  _tokenAddress: Bytes! # address
  _to: Bytes! # address
  _amount: BigInt! # uint256
  _symbol: String! # string
  _userData: Bytes! # bytes
  _decimals: Int! # uint8
  _granularity: BigInt! # uint256
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ErrorTokenReceiver @entity {
  id: ID!
  _errorData: Bytes! # bytes
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type FederationChanged @entity {
  id: ID!
  _newFederation: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type NewSideToken @entity {
  id: ID!
  _newSideTokenAddress: Bytes! # address
  _originalTokenAddress: Bytes! # address
  _newSymbol: String! # string
  _granularity: BigInt! # uint256
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type OwnershipTransferred @entity {
  id: ID!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Paused @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PauserAdded @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PauserRemoved @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PrefixUpdated @entity {
  id: ID!
  _isSuffix: Boolean! # bool
  _prefix: String! # string
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type RevokeTx @entity {
  id: ID!
  tx_revoked: Bytes! # bytes32
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SideTokenFactoryChanged @entity {
  id: ID!
  _newSideTokenFactory: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Unpaused @entity {
  id: ID!
  account: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Upgrading @entity {
  id: ID!
  isUpgrading: Boolean! # bool
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type erc777ConverterSet @entity {
  id: ID!
  erc777ConverterAddress: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

enum BridgeType {
  RSK_BSC
  RSK_ETH
}

type Bridge @entity {
  id: ID! # Bridge address
  type: BridgeType! # BridgeType
  federations: [Federation!] @derivedFrom(field: "bridge")
  isUpgrading: Boolean! # boolean
  isPaused: Boolean! # boolean
  totalFundsSent: BigInt! # uint256
  totalFundsReceived: BigInt! # uint256
  feesCollected: BigInt! # uint256
  pausers: [Bytes!]! # address[]
  createdAtTx: Transaction! # Transaction
  updatedAtTx: Transaction! # Transaction
}

enum CrossDirection {
  Incoming
  Outgoing
}

enum CrossStatus {
  Voting
  Executed
  # FAILED
}

type CrossTransfer @entity {
  id: ID! # TransactionIdU
  direction: CrossDirection! # CrossDirection
  votes: Int # uint8
  status: CrossStatus! # CrossStatus
  originalTokenAddress: Bytes
  tokenAddress: Bytes! # address
  token: Token
  to: User! # address
  amount: BigDecimal!
  symbol: String # string
  sourceChainBlockHash: Bytes # bytes
  sourceChainTransactionHash: Bytes # bytes
  # userData: Bytes! # bytes
  # decimals: Int! # uint8
  # granularity: BigInt! # uint256
  # formattedAmount: BigInt! # uint256
  # calculatedDecimals: Int! # uint8
  # calculatedGranularity: BigInt! # uint256

  createdAtTx: Transaction! # Transaction
  updatedAtTx: Transaction! # Transaction
}
