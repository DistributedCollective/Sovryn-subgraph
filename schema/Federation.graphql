type BridgeChanged @entity {
  id: ID!
  bridge: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Executed @entity {
  id: ID!
  transactionId: Bytes! # bytes32
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type MemberAddition @entity {
  id: ID!
  member: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type MemberRemoval @entity {
  id: ID!
  member: Bytes! # address
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type RequirementChange @entity {
  id: ID!
  required: BigInt! # uint256
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type RevokeTxAndVote @entity {
  id: ID!
  tx_revoked: Bytes! # bytes32
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type StoreFormerFederationExecutedTx @entity {
  id: ID!
  # tx_stored: [Bytes]! # bytes32[]
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Voted @entity {
  id: ID!
  sender: Bytes! # address
  transactionId: Bytes! # bytes32
  originalTokenAddress: Bytes! # address
  receiver: Bytes! # address
  amount: BigInt! # uint256
  symbol: String! # string
  blockHash: Bytes! # bytes32
  transactionHash: Bytes! # bytes32
  logIndex: BigInt! # uint32
  decimals: Int! # uint8
  granularity: BigInt! # uint256
  userData: Bytes! # bytes
  timestamp: Int!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Federation @entity {
  id: ID! # Bridge address
  # type: BridgeType! # BridgeType
  bridge: Bridge!
  totalVotes: Int!
  totalExecuted: Int!
  members: [Bytes!]!
  createdAtTx: Transaction! # Transaction
  updatedAtTx: Transaction! # Transaction
}
