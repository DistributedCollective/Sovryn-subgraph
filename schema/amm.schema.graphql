# AMM SCHEMA

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry @entity {
  """
  ID is the address of the converter registry contract
  """
  id: ID!
  """
  All the converters (AMM pools) associated with this registry
  """
  converters: [LiquidityPool!] @derivedFrom(field: "currentConverterRegistry")
  smartTokens: [SmartToken!] @derivedFrom(field: "currentConverterRegistry")
  connectorTokens: [Token!] @derivedFrom(field: "currentConverterRegistry")
  owner: Bytes! # address
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtBlockNumber: BigInt
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtTransactionHash: String
  lastUsedAtBlockNumber: BigInt
  numConverters: BigInt!
}

"""
The smart token represents a single reserve asset on a single pool. 
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken @entity {
  """
  ID is smart token address
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String # Relay, Liquid, BNT?, Others?
  transfersEnabled: Boolean
  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool! @derivedFrom(field: "smartToken")
  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens: [TokenSmartToken!] @derivedFrom(field: "smartToken")
  owner: Bytes!
  # tokenSwapTotals: [TokenSwapTotal!] @derivedFrom(field: "toToken")
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: BigInt
  addedToRegistryTransactionHash: Bytes
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken @entity {
  """
  ID is token address + smart token address
  """
  id: ID!
  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
  smartToken: SmartToken!
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken @entity {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  converters: [LiquidityPoolToken!] @derivedFrom(field: "poolToken") #TODO: Does this need a many-to-many relationship?
  underlyingAssets: [TokenPoolToken!] @derivedFrom(field: "poolToken")
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap @entity {
  """
  Transaction hash of this swap
  """
  id: ID!
  """
  The AMM Conversion events involved in this swap
  """
  conversions: [Conversion!] @derivedFrom(field: "swapTransaction")
  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!
  fromToken: Token!
  toToken: Token!
  fromAmount: BigDecimal!
  toAmount: BigDecimal!
  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: BigDecimal!
  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null
  """
  user: User
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  timestamp: BigInt!
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted. Although this is pretty useful, maybe keep
"""
type Conversion @entity {
  id: ID!
  _fromToken: Token! # address
  _toToken: Token! # address
  _trader: Bytes! # address
  _amount: BigInt! # uint256
  _return: BigInt! # uint256
  _conversionFee: BigInt! # int256
  _protocolFee: BigInt! # int256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  swapTransaction: Swap!
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool @entity {
  """
  ID is the contract address of the Converter
  """
  id: ID!
  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
  smartToken: SmartToken
  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token
  token1: Token
  connectorTokens: [LiquidityPoolToken!]! @derivedFrom(field: "liquidityPool")
  poolTokens: [TokenPoolToken!]! @derivedFrom(field: "liquidityPool")
  owner: String
  conversionFee: BigInt
  weight: BigInt
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  # hasRBTCReserve: Boolean!
  maxConversionFee: BigInt
  # reserveRatio: Int!
  # activated: Boolean!
  # numSwaps: BigInt!
  lastResetBlockNumber: BigInt
  lastResetTimestamp: BigInt
  createdAtTimestamp: BigInt
  createdAtBlockNumber: BigInt
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
  # OTHER FIELDS TO ADD HERE
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and so
"""
type LiquidityPoolToken @entity {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  token: Token!
  liquidityPool: LiquidityPool!
  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  # balance: BigInt! # Balance is hard to implement because pools were initially funded not through the LiquidityAdded event
  volumeBought: BigDecimal!
  volumeSold: BigDecimal!
  totalVolume: BigDecimal!
}

"""
The entity stores the many-to-many relationship between underlying tokens and pool tokens
"""
type TokenPoolToken @entity {
  """
  ID is token address + poolToken address
  """
  id: ID! 
  token: Token!
  poolToken: PoolToken!
  liquidityPool: LiquidityPool!
}

#### GENERATED BY SCAFFOLD SCRIPT - Add any custom entities before this line

type NewConverter @entity {
  id: ID!
  _type: Int! # uint16
  _converter: Bytes! # address
  _owner: Bytes! # address
  timestamp: BigInt!
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolAdded @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolRemoved @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenAdded @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenRemoved @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}