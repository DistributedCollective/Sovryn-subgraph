schema {
  query: Query
  subscription: Subscription
}

"""
BridgeType - only 2 bridges at the moment - RSK <-> BSC and RSK <-> ETH
"""
enum BridgeType {
  RSK_BSC
  RSK_ETH
}
"""
Cross Chain Bridge
"""
type Bridge @entity {
  """
  Bridge ID - Bridge Contract Address
  """
  id: ID! # Bridge address
  """
  BridgeType - there are currently only two bridges - RSK_BSC and RSK_ETH
  """
  type: BridgeType! # BridgeType
  """
  Prefix - prefix added to sideTokens symbol when created
  """
  prefix: String
  """
  isSuffix - is suffix or prefix
  """
  isSuffix: Boolean
  """
  Federation - the Federation entity associated with this bridge
  """
  federation: Federation!
  """
  isUpgrading - Indicates if the bridge is currently upgrading
  """
  isUpgrading: Boolean! # boolean
  """
  isPaused - Indicates if the bridge is currently paused
  """
  isPaused: Boolean! # boolean
  """
  Pausers - an array of addresses authorized to pause the bridge
  """
  pausers: [String!]! # address[]
  """
  CreatedAtTx - The bridge creation transaction
  """
  createdAtTx: Transaction! # Transaction
  """
  UpdatedAtTx - The bridge last updated at this transaction
  """
  updatedAtTx: Transaction! # Transaction
}

"""
Federation - the federation entity
"""
type Federation @entity {
  """
  Id - the id of the federation entity is the federation contract address
  """
  id: ID! # Bridge address
  """
  IsActive - is this federation contract active
  """
  isActive: Boolean! # Is active
  """
  Bridge - the bridge that is associated with this federation contract
  """
  bridge: Bridge!
  """
  TotalVotes - total votes cast on this federation
  """
  totalVotes: Int!
  """
  TotalExecuted - total transfers executed by this federation
  """
  totalExecuted: Int!
  """
  Members - federators that are members of this federation
  """
  members: [String!]!
  """
  CreatedAtTx - the creation transaction of this federation
  """
  createdAtTx: Transaction! # Transaction
  """
  UpdatedAtTx - the transaction at which this entity was last updated
  """
  updatedAtTx: Transaction! # Transaction
}

enum CrossDirection {
  Incoming
  Outgoing
}

enum CrossStatus {
  Voting
  Executed
  Revoked
}

enum BridgeChain {
  RSK
  ETH
  BSC
}

type CrossTransfer @entity {
  """
  Id - the cross transfer Id - for outgoing it is generated from the cross event params for incoming it is coming from the federation events
  """
  id: ID! # TransactionIdU
  """
  Direction - the direction of the cross transfer (Incoming or Outgoing)
  """
  direction: CrossDirection! # CrossDirection
  """
  sourceChain - the source chain - for outgoing it is RSK and for incoming it is BSC/ETH
  """
  sourceChain: BridgeChain!
  """
  DestinationChain - the destination chain - for outgoing it is BSC/ETH and for incoming it is RSK
  """
  destinationChain: BridgeChain!
  """
  Votes - Number of votes cast for this transfer
  """
  votes: Int # uint8
  """
  Status - transfer status - Voting, Executed, Revoked
  """
  status: CrossStatus! # CrossStatus
  """
  originalTokenAddress - the original token address for the transfer (for outgoing it is just the RSK token address)
  """
  originalTokenAddress: String!
  """
  TokenAddress - the token address for the transfer (only relevant for incoming transfers)
  """
  tokenAddress: String # address
  """
  Token - the token entity if exist of original token address
  """
  token: Token # Token
  """
  sideToken - the SideToken entity if exist of original token address
  """
  sideToken: SideToken # SideToken
  """
  Receiver - The receiver of funds (can be a wallet or contract)
  """
  receiver: String # address
  """
  Sender - The sender of funds (can be a wallet or contracts)
  """
  sender: String
  """
  Amount - the amount of originalToken transferred across the bridge
  """
  amount: String!
  """
  Symbol - the token symbol
  """
  symbol: String # string
  """
  SourceChainBlockHash - the source chain block hash of the transfer, for outgoing transfers this is just the RSK block hash
  """
  sourceChainBlockHash: String # bytes
  """
  SourceChainTransactionHash - the source chain transaction hash of the transfer, for outgoing transfers this is just the RSK transaction hash
  """
  sourceChainTransactionHash: String # bytes
  """
  CreatedAtTx - the transaction at which this transfer was created
  """
  createdAtTx: Transaction! # Transaction
  """
  CreatedAtTimestamp - the timestamp at which this transfer was created
  """
  createdAtTimestamp: Int!
  """
  updatedAtTx - the transaction at which this transfer was last updated
  """
  updatedAtTx: Transaction! # Transaction
  """
  updatedAtTimestamp - the timestamp at which this transfer was last updated
  """
  updatedAtTimestamp: Int!
}

"""
SideToken entity - for every token that is passed across the bridge and does not exist on sovryn a side token is created
"""
type SideToken @entity {
  """
  Id - the side token is stored twice, once with the original token address as id and another with the side token address
  """
  id: ID!
  """
  OriginalTokenAddress - the original token address of the side token
  """
  originalTokenAddress: String!
  """
  SideTokenAddress - the token address on RSK of the side token
  """
  sideTokenAddress: String!
  """
  newSymbol - the new symbol given to the side token
  """
  newSymbol: String!
  """
  Granularity - this is the ERC777 granularity value for the side token
  """
  granularity: String!
  """
  CreatedAtTx - the creation transaction of the side token
  """
  createdAtTx: Transaction! # Transaction
  """
  UpdatedAtTx - The side token was last updated at this transaction
  """
  updatedAtTx: Transaction! # Transaction
}

# AMM SCHEMA

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry @entity {
  """
  ID is the address of the converter registry contract
  """
  id: ID!
  """
  All the converters (AMM pools) associated with this registry
  """
  converters: [LiquidityPool!] @derivedFrom(field: "currentConverterRegistry")
  """
  All smart tokens in this registry
  """
  smartTokens: [SmartToken!] @derivedFrom(field: "currentConverterRegistry")
  """
  All ERC20 tokens in this registry
  """
  connectorTokens: [Token!] @derivedFrom(field: "currentConverterRegistry")
  """
  The contract/account that owns the registry
  """
  owner: String! # address
  """
  The number of active converters (AMM pools) in this registry
  """
  numConverters: Int!
}

"""
The smart token represents a single reserve asset on a single pool.
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken @entity {
  """
  ID is smart token contract address
  """
  id: ID!
  """
  Name of the smart token (set on the contract)
  """
  name: String
  """
  Symbol for the smart token asset (set on the contract)
  """
  symbol: String
  """
  Number of decimal places for this token
  """
  decimals: Int
  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String # Relay, Liquid, BNT?, Others?
  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool! @derivedFrom(field: "smartToken")
  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens: [TokenSmartToken!] @derivedFrom(field: "smartToken")
  """
  The contract/account that owns the SmartToken contract. This will typically be the converter registry
  """
  owner: String!
  """
  The converter registry this smart token belongs to. Can be null if token is removed from th registry
  """
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: Int
  addedToRegistryTransactionHash: String
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken @entity {
  """
  ID is token address + smart token address
  """
  id: ID!
  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
  smartToken: SmartToken!
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken @entity {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  liquidityPool: LiquidityPool!
  """
  For V1 pools, there will be 2 underlying assets, however for V2 pools there will be just one
  """
  underlyingAssets: [Token!]!
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap @entity {
  """
  Transaction hash of this swap
  """
  id: ID!
  """
  The AMM Conversion events involved in this swap
  """
  conversions: [Conversion!] @derivedFrom(field: "swapTransaction")
  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!
  """
  Token the user converted
  """
  fromToken: Token!
  """
  Token the user received
  """
  toToken: Token!
  fromAmount: String!
  toAmount: String!
  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: String!
  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null.
  Otherwise, this is the user that initiated the transaction.
  """
  user: User
  """
  Was this swap part of a margin trade?
  """
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  """
  Was this swap a limit order?
  """
  isLimit: Boolean!
  timestamp: Int!
  transaction: Transaction!
}

"""
Granular Conversion events, exactly as they appear on the contracts.
These events are the raw data that the Swap entity and candlestick entities are built from.
"""
type Conversion @entity {
  id: ID!
  _fromToken: Token! # address
  _toToken: Token! # address
  _trader: String! # address
  _amount: String! # uint256
  _return: String! # uint256
  _conversionFee: String! # int256
  _protocolFee: String! # int256
  timestamp: Int!
  emittedBy: LiquidityPool! #address
  transaction: Transaction!
  swapTransaction: Swap!
  blockNumber: Int!
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool @entity {
  """
  ID is the contract address of the Converter
  """
  id: ID!
  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
  smartToken: SmartToken
  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token
  token1: Token
  """
  The balance for each token on this liquidity pool
  NB: For the V2 pools (USDT, DOC, BPRO), this balance is the staked balance, not the contract balance
  """
  token0Balance: String!
  token1Balance: String!
  connectorTokens: [LiquidityPoolToken!]! @derivedFrom(field: "liquidityPool")
  poolTokens: [PoolToken!] @derivedFrom(field: "liquidityPool")
  owner: String
  """
  Divide by maxConversionFee to get percentage
  """
  conversionFee: String # This is in percent if you divide by maxConversionFee
  # weight: String
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  # hasRBTCReserve: Boolean!
  maxConversionFee: String
  createdAtTimestamp: Int
  createdAtBlockNumber: Int
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and sold, but this should be moved to the LiquidityPool
"""
type LiquidityPoolToken @entity {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  token: Token!
  liquidityPool: LiquidityPool!
  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  """
  Total volume of this token bought through this liquidity pool
  """
  volumeBought: String!
  """
  Total volume of this token sold through this liquidity pool
  """
  volumeSold: String!
  """
  Total volume of this token that has been bought or sold through this liquidity pool
  """
  totalVolume: String!
}

# Candlesticks
enum CandleSticksInterval {
  MinuteInterval
  FifteenMinutesInterval
  HourInterval
  FourHourInterval
  DayInterval
}

"""
Candlesticks are for presentational purposes on the dapp. This entity supports the candlestick trading data on the trading view charts.
Trading data is available for the following pairs:
1. All tokens to RBTC
2. All tokens to current usdStablecoin (see ProtocolStats entity for more information)
There is not candlestick data for other trading pairs as this would cause the amount of data stored to increase exponentially
"""
interface ICandleStick {
  """
  The ID is fromToken + toToken + timestamp
  toToken will be either RBTC or XUSD
  """
  id: ID!
  """
  Eg in the pair SOV-XUSD, the base token is SOV and the quote token is XUSD
  Prices shown are the price of the base token in the quote token (eg price of SOV in XUSD)
  """
  baseToken: Token
  quoteToken: Token

  open: String # opening price
  high: String! # high price
  low: String! # low price
  close: String! # close price
  txCount: Int! # number of transactions during period
  """
  The volume of the base token that has been bought and sold in this time period
  """
  totalVolume: String!
  """
  Unix timestamp for the candlestick start time
  """
  periodStartUnix: Int!
}

type CandleStickMinute implements ICandleStick @entity {
  id: ID! # fromToken + toToken + timestamp + interval
  baseToken: Token
  quoteToken: Token
  open: String # opening price
  high: String! # high price
  low: String! # low price
  close: String! # close price
  txCount: Int! # number of transactions during period
  totalVolume: String! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}

type CandleStickFifteenMinute implements ICandleStick @entity {
  id: ID! # fromToken + toToken + timestamp + interval
  baseToken: Token
  quoteToken: Token
  open: String # opening price
  high: String! # high price
  low: String! # low price
  close: String! # close price
  txCount: Int! # number of transactions during period
  totalVolume: String! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}

type CandleStickHour implements ICandleStick @entity {
  id: ID! # fromToken + toToken + timestamp + interval
  baseToken: Token
  quoteToken: Token
  open: String # opening price
  high: String! # high price
  low: String! # low price
  close: String! # close price
  txCount: Int! # number of transactions during period
  totalVolume: String! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}

type CandleStickFourHour implements ICandleStick @entity {
  id: ID! # fromToken + toToken + timestamp + interval
  baseToken: Token
  quoteToken: Token
  open: String # opening price
  high: String! # high price
  low: String! # low price
  close: String! # close price
  txCount: Int! # number of transactions during period
  totalVolume: String! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}

type CandleStickDay implements ICandleStick @entity {
  id: ID! # fromToken + toToken + timestamp + interval
  baseToken: Token
  quoteToken: Token
  open: String # opening price
  high: String! # high price
  low: String! # low price
  close: String! # close price
  txCount: Int! # number of transactions during period
  totalVolume: String! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}

type BitcoinTransferBatchSending @entity {
  id: ID!
  bitcoinTxHash: String! # bytes32
  transferBatchSize: Int! # uint8
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

enum BitcoinTransferStatus {
  """
  the transfer slot has not been initialized
  """
  NOT_APPLICABLE
  """
  the transfer was initiated
  """
  NEW
  """
  the federators have approved this transfer as part of a transfer batch
  """
  SENDING
  """
  the transfer was confirmedly mined in Bitcoin blockchain
  """
  MINED
  """
  the transfer was refunded
  """
  REFUNDED
  """
  the transfer was reclaimed by the user
  """
  RECLAIMED
}

type BitcoinTransfer @entity {
  id: ID! # transferId
  btcAddress: String!
  nonce: Int!
  amountBTC: String!
  feeBTC: String!
  totalAmountBTC: String!
  user: User! # user
  status: BitcoinTransferStatus!
  bitcoinTxHash: String!
  createdAtTimestamp: Int!
  createdAtBlockNumber: Int!
  createdAtTx: Transaction!
  updatedAtTimestamp: Int!
  updatedAtBlockNumber: Int!
  updatedAtTx: Transaction!
}

type FastBTCBridgeStat @entity {
  id: ID!
  user: User
  totalAmountBTCInitialized: String!
  totalAmountBTCSending: String!
  totalAmountBTCMined: String!
  totalFeesBTC: String!
  totalAmountBTCRefunded: String!
  createdAtTx: Transaction!
  updatedAtTx: Transaction!
}

# Governor contracts

"""
A Proposal is created each time a SIP (Sovryn Improvement Proposal) is proposed
The Proposal is created, voted on, and then executed if it passes
To see if a Proposal has been executed, see if the executed property is null or if it has a transaction
"""
type Proposal @entity {
  """
  ID is the address of the governor contract that was used to create the proposal, + the id of the proposal
  """
  id: ID!
  """
  Transaction that created the proposal
  """
  created: Transaction!
  """
  If the proposal was canceled, the transaction that canceled it (otherwise null)
  """
  canceled: Transaction
  """
  If the proposal was executed, the transaction that executed it (otherwise null)
  """
  executed: Transaction
  """
  If the proposal was queued, the transaction that queued it (otherwise null)
  """
  queued: Transaction
  """
  Number of votes for the proposal (weighted vote, not number of voters)
  """
  votesFor: String!
  """
  Number of votes against the proposal (weighted vote, not number of voters)
  """
  votesAgainst: String!
  """
  Number of unique wallets that voted for this proposal
  """
  countVotersFor: Int!
  """
  Number of unique wallets that voted against this proposal
  """
  countVotersAgainst: Int!
  """
  Individual vote transactions
  """
  votes: [VoteCast!] @derivedFrom(field: "proposal")
  proposalId: Int!
  """
  Address of the user who created this proposal
  """
  proposer: String! # address
  """
  Contract or contracts that this proposal targets
  """
  targets: [String!]! # address[]
  values: [String!]! # uint256[]
  """
  Function signatures in the targeted contract that would be affected by this proposal passing
  """
  signatures: [String!]! # string[]
  """
  Block when voting starts
  """
  startBlock: Int! # uint256
  """
  Block when voting ends
  """
  endBlock: Int! # uint256
  """
  Brief description of what this SIP is for, sometimes with a link to the github repo and README for this proposal
  """
  description: String! # string
  """
  Timestamp when this proposal was created. This is also available in the created transaction, but is included here so it is possible to order by timestamp
  """
  timestamp: Int!
  """
  The contract that emitted this event
  """
  emittedBy: String! #address
}

"""
This is the event emitted when a user votes for or against a proposed SIP
"""
type VoteCast @entity {
  """
  ID is transaction hash + log index
  """
  id: ID!
  voter: User! # address
  """
  The ID of the proposal
  """
  proposalId: Int! # uint256
  """
  The ID of the Proposal entity that this vote is for/against
  """
  proposal: Proposal!
  """
  True if the vote is for the proposal, False if it is against
  """
  support: Boolean! # bool
  """
  The number of votes the user cast (the voting power of that user)
  """
  votes: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool @entity {
  """
  ID is the contract address of the iToken
  """
  id: ID!
  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
  """
  The total supply of this pool token (not the underlying asset).
  It is incremented on Mint events and decremented on Burn events
  """
  poolTokenBalance: String!
  """
  Balance of the underlying asset (ERC20 token) represented by the total supply of pool tokens
  It is incremented on Mint events and decremented on Burn events.
  WORK-IN-PROGRESS: This is a work-in-progress as it does not properly account for interest payments currently
  """
  assetBalance: String!
  """
  Total asset volume lent over all time
  """
  totalAssetLent: String!
}

"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory @entity {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!
  user: User!
  lendingPool: LendingPool!
  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory: [LendingHistoryItem!] @derivedFrom(field: "userLendingHistory")
  """
  Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: String!
  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: String!
}

enum LendingHistoryType {
  """
  Lend is equivalent to a Mint event
  """
  Lend
  """
  UnLend is equivalent to a Burn event
  """
  UnLend
}

"""
LendingHistoryItem is one user's history of Lend/UnLend events across all the lending pools
"""
type LendingHistoryItem @entity {
  id: ID! # tx hash
  lender: User!
  """
  Type is Lend/UnLend
  """
  type: LendingHistoryType!
  """
  The lending pool the user interacted with
  """
  lendingPool: LendingPool!
  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token
  """
  The amount of ERC20 token that was lent/unlent
  """
  amount: String!
  """
  The amount of pool token that was minted or burned
  """
  loanTokenAmount: String!
  timestamp: Int!
  transaction: Transaction!
  emittedBy: String!
  """
  Foreign key to the UserLendingHistory entity (see the docs on this entity for more information)
  """
  userLendingHistory: UserLendingHistory!
}

"""
This entity stores one User's history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory @entity {
  """
  The ID is userAddress + '-' + smartToken
  Liquidity Pool address is not used here because when a liquidity pool is updated the address changes, but the smart token address remains the same.
  """
  id: ID!
  user: User!
  """
  This is the pool token (sometimes called smart token), not the liquidity pool address
  """
  poolToken: PoolToken!
  """
  Asset0 is defined on the LiquidityPool.
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset0LiquidityAdded: String!
  totalAsset0LiquidityRemoved: String!
  """
  Asset1 is defined on the LiquidityPool
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset1LiquidityAdded: String!
  totalAsset1LiquidityRemoved: String!
  """
  Granular transaction history for transactions adding or removing liquidity from an AMM pool
  """
  liquidityHistory: [LiquidityHistoryItem!] @derivedFrom(field: "userLiquidityHistory")
}

enum LiquidityHistoryType {
  Added
  Removed
}

type LiquidityHistoryItem @entity {
  """
  ID is transaction hash + log index
  """
  id: ID!
  user: User!
  """
  Foreign key to join this transaction to the parent UserLiquidityHistory entity
  """
  userLiquidityHistory: UserLiquidityHistory!
  """
  Type is either Added or Removed (if a user added or removed liquidity from the pool)
  """
  type: LiquidityHistoryType! # Added or removed
  """
  Provider is either the user, or a contract if the user interacted with a proxy contract
  """
  provider: String! # address
  """
  The underlying asset (ERC20 token) that was added/removed
  """
  reserveToken: Token! # address
  """
  The amount that was added/removed
  """
  amount: String! # uint256
  """
  New balance of the reserveToken (ERC20 token) on the AMM pool
  """
  newBalance: String! # uint256
  """
  New total supply of pool tokens
  """
  newSupply: String! # uint256
  timestamp: Int!
  """
  AMM pool that liquidity was provided to
  """
  liquidityPool: LiquidityPool!
  """
  The contract that emitted this event (primarily used for debugging)
  """
  emittedBy: String! #address
  transaction: Transaction!
}

# Loans
enum LoanType {
  """
  Trade is a loan originating from a margin trade
  """
  Trade
  """
  Borrow is a loan originating from a user simply borrowing funds
  """
  Borrow
}

"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan @entity {
  id: ID! # ID is LoanId
  """
  The token the loan was taken out in
  """
  loanToken: Token!
  """
  The token provided as collateral
  """
  collateralToken: Token!
  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!
  """
  Unix timestamp at start of loan
  """
  startTimestamp: Int!
  """
  Unix timestamp at end of loan (null if loan is still open)
  """
  endTimestamp: Int
  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: String!
  """
  The amount borrowed when the loan was opened
  """
  startBorrowedAmount: String!
  """
  The largest amount borrowed in the lifetime of this loan
  """
  maxBorrowedAmount: String!

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: String!
  """
  Initial size of the position
  """
  startPositionSize: String!
  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: String!
  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: String!
  """
  If a Liquidate, CloseWithSwap, Rollover or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!
  """
  Next date that the loan will be rolled over, interest and trading fee paid, and rollover reward paid
  It is possible for the next rollover to be in the past if the loan has not yet been rolled over by the Sovryn node
  """
  nextRollover: Int
  """
  The user who took out the loan
  """
  user: User!
  """
  Trade (margin trade) transactions associated with this loan
  """
  trade: [Trade!] @derivedFrom(field: "loanId")
  """
  Borrow transactions associated with this loan
  """
  borrow: [Borrow!] @derivedFrom(field: "loanId")
  """
  CloseWithSwap events associated with this loan. Emitted when a user partially or fully closes a margin trade.
  """
  closeWithSwaps: [CloseWithSwap!] @derivedFrom(field: "loanId")
  """
  CloseWithDeposit events associated with this loan. Emitted when a user partially or fully closes a borrow loan.
  """
  closeWithDeposits: [CloseWithDeposit!] @derivedFrom(field: "loanId")
  """
  Any liquidations that have happened on this loan
  """
  liquidates: [Liquidate!] @derivedFrom(field: "loanId")
  """
  DepositCollateral events associated with this loan, where a user has topped up collateral
  """
  depositCollateral: [DepositCollateral!] @derivedFrom(field: "loanId")
  """
  Rollover events associated with this loan.
  Rollovers are loan maintenance transactions where the next interest payment and fee is paid
  """
  rollovers: [Rollover!] @derivedFrom(field: "loanId")
  """
  Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token
  """
  totalBought: String!
  """
  Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token
  """
  totalSold: String!
  """
  Average price per token from all loan open events
  Updated on Trade and Borrow events
  This is mainly used as internal storage to calculate PnL
  """
  averageBuyPrice: String!
  """
  Average price per token from all loan close events
  Updated on CloseWithSwap, CloseWithDeposit and Liquidate events
  This is mainly used as internal storage to calculate PnL
  """
  averageSellPrice: String!
  """
  Realized profit and loss. This is updated on every loan closing event - partially or fully closing a loan, or a liquidation.
  Currently, this does not take into account fees paid
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: String!
  """
  Percentage profit or loss relative to collateral
  """
  realizedPnLPercent: String!
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow @entity {
  id: ID!
  user: User! # address
  lender: String! # address
  loanId: Loan! # bytes32
  loanToken: String! # address
  collateralToken: String! # address
  newPrincipal: String! # uint256
  newCollateral: String! # uint256
  interestRate: String! # uint256
  interestDuration: String! # uint256
  collateralToLoanRate: String! # uint256
  currentMargin: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit @entity {
  id: ID!
  user: String! # address
  lender: String! # address
  loanId: Loan! # bytes32
  closer: String! # address
  loanToken: String! # address
  collateralToken: String! # address
  repayAmount: String! # uint256
  collateralWithdrawAmount: String! # uint256
  collateralToLoanRate: String! # uint256
  currentMargin: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap @entity {
  id: ID!
  user: String! # address
  lender: String! # address
  loanId: Loan! # bytes32
  collateralToken: String! # address
  loanToken: String! # address
  closer: String! # address
  positionCloseSize: String! # uint256
  loanCloseAmount: String! # uint256
  exitPrice: String! # uint256
  """
  Leverage on the smart contract does not count user-provided collateral.
  So, what would on the dapp be a 2x leverage trade would be a 1 here
  """
  currentLeverage: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral @entity {
  id: ID!
  loanId: Loan! # bytes32
  depositAmount: String! # uint256
  """
  Rate is sometimes null because this property was not included in older versions of the contract
  """
  rate: String # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate @entity {
  id: ID!
  user: User! # address
  liquidator: String! # address
  loanId: Loan! # bytes32
  lender: String! # address
  loanToken: String! # address
  collateralToken: String! # address
  repayAmount: String! # uint256
  collateralWithdrawAmount: String! # uint256
  collateralToLoanRate: String! # uint256
  currentMargin: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee @entity {
  id: ID!
  payer: String! # address
  token: String! # address
  loanId: Loan! # bytes32
  amount: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over
"""
type PayLendingFee @entity {
  id: ID!
  payer: String! # address
  token: String! # address
  amount: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee @entity {
  id: ID!
  payer: String! # address
  token: String! # address
  loanId: Loan! # bytes32
  amount: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user opens a Margin Trade
"""
type Trade @entity {
  id: ID!
  user: User!
  lender: String!
  loanId: Loan!
  collateralToken: Token!
  loanToken: Token!
  positionSize: String!
  borrowedAmount: String!
  interestRate: String!
  settlementDate: Int!
  entryPrice: String!
  entryLeverage: String!
  currentLeverage: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a Loan is rolled over.
This is when the next installment of interest is paid from the collateral, and the trading fee is paid
This transaction is initiated by the Sovryn node, which earns a reward for doing this
"""
type Rollover @entity {
  id: ID!
  user: User!
  lender: String!
  loanId: Loan!
  principal: String!
  collateral: String!
  endTimestamp: Int!
  """
  The User running the Sovryn node that made this transaction
  """
  rewardReceiver: User!
  """
  The reward received by the User for performing this function
  """
  reward: String!
  timestamp: Int!
  emittedBy: String!
  transaction: Transaction!
}

# This is the orderbooks for testnet and mainnet. Both orderbooks are created on testnet. This event will never be emitted on mainnet.
# This is suboptimal, we are thinking of a better solution

enum Network {
  Mainnet
  Testnet
}

type OrderCreated @entity {
  id: ID!
  hash: String! # bytes32
  network: Network!
  """
  This is the User address. This is not a User entity because of the testnet/mainnet issue (see above comment)
  """
  order_maker: String! # address
  order_fromToken: String! # address
  order_toToken: String! # address
  """
  The amountIn is a String (usually 1e18), not a human-readable decimal.
  This is because both orderbooks are on testnet, and so this subgraph cannot access the correct number of token decimals for mainnet tokens
  """
  order_amountIn: String! # Keep as BigInt, do not convert to String
  """
  The amountIn is a String (usually 1e18), not a human-readable decimal. (See above for explanation)
  """
  order_amountOutMin: String! # Keep as BigInt, do not convert to String
  order_recipient: String! # address
  """
  Timestamp when the order must be filled by
  """
  order_deadline: String! # Keep as BigInt, do not convert to String
  """
  Timestamp when the order was created
  """
  order_created: String! # Keep as BigInt, do not convert to String
  """
  The price at which the order should be executed.
  This is a String (usually 1e18), not a human-readable decimal. (See above for explanation)
  """
  limitPrice: String! # Keep as BigInt, do not convert to String
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

# PROTOCOL LEVEL ENTITIES

"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats @entity {
  """
  Only one entity should be created, with ID "0"
  """
  id: ID!
  """
  An array of all tokens in the protocol
  """
  tokens: [Token!]!
  """
  The token currently used as a proxy for USD/BTC prices
  """
  usdStablecoin: Token!
  """
  Current price of BTC in usdStablecoin
  """
  btcUsdPrice: String!
  """
  Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
  Incremented when a user interacts with any contracts tracked by this subgraph.
  Does not include the Zero, Mynt and Perperpetual Swaps users (unless they have also used the core protocol)
  """
  totalUsers: Int!
  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: String!
  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: String!
  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: String!
  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: String!
  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: String!
  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: String!
  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: String!
  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: String!
  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: String!
  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: String!
  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: String!
  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: String!
  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: String!
  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: String!
  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  currentVoluntarilyStakedSov: String!
  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  currentStakedByVestingSov: String!
  # """
  # NOT YET IMPLEMENTED: This will be a total of volumes of all transaction types (AMM Swaps, Margin Trades, CloseWithSwap etc etc)
  # """
  # totalTransactedVolumeUsd: Int! # TODO: Implement
}

"""
Transaction data, including hash and timestamp
"""
type Transaction @entity {
  """
  ID is transaction hash
  """
  id: ID!
  blockNumber: Int!
  """
  The timestamp the transaction was confirmed
  """
  timestamp: Int!
  gasPrice: String!
  """
  The index of this transaction within the block
  """
  index: Int!
  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: User!
  """
  The contract the user interacted with
  """
  to: String
  value: String!
  gasLimit: String!
}

"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token @entity {
  """
  The ID is the contract address of the token on RSK
  """
  id: ID!
  name: String
  symbol: String
  """
  Number of decimal places used in the smart contract for this token
  """
  decimals: Int
  version: Int
  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools: [LiquidityPoolToken!] @derivedFrom(field: "token")
  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens: [TokenSmartToken!] @derivedFrom(field: "token")
  # tokenSwapTotals: [TokenSwapTotals!]
  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceBtc: String!
  """
  lastPriceBtc is the last traded price of this token in BTC
  """
  lastPriceBtc: String!
  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceUsd: String!
  """
  lastPriceUsd is the last traded price of this token in USD
  """
  lastPriceUsd: String!
  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: String!
  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: String!
  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: String!
  currentConverterRegistry: ConverterRegistry
  """
  Does this token have an AMM pool with rBTC as the other reserve asset?
  """
  hasBtcPool: Boolean
  """
  Does this token have an AMM pool with the protocol stablecoin as the other reserve asset?
  """
  hasStablecoinPool: Boolean

  """
  CrossTransfers: cross transfers list (currently only relevant to SOV)
  """
  crossTransfers: [CrossTransfer!] @derivedFrom(field: "token")
}

type OwnerUpdate @entity {
  id: ID!
  prevOwner: String!
  newOwner: String!
  timestamp: String!
  emittedBy: String!
}

"""
This entity contains the history, fees and totals regarding one users' SOV rewards
"""
type UserRewardsEarnedHistory @entity {
  id: ID! # user
  user: User!
  """
  This is the total of all EarnReward and RewardClaimed events
  """
  totalFeesAndRewardsEarned: String!
  """
  SOV rewards earned from margin trading, but not yet claimed and vested
  Incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract
  """
  availableTradingRewards: String!
  """
  Sum of all SOV rewards earned from margin trading.
  Incremented by EarnReward events
  """
  totalTradingRewards: String!
  """
  Granular events for transaction where a reward is earned
  """
  rewardsEarnedHistory: [RewardsEarnedHistoryItem!] @derivedFrom(field: "user")
}

enum RewardsEarnedAction {
  """
  When a SOV Staker withdraws their liquid SOV reward for staking
  """
  StakingRewardWithdrawn
  """
  SOV reward earned when a user margin trades or one of their trades is rolled over.
  The reward is a percentage of the trading fee, paid in SOV.
  """
  EarnReward
  """
  When a user claims a liquidity mining reward
  """
  RewardClaimed
  """
  When SOV is staked by a Rewards vesting contract (eg after it has been claimed by the user)
  """
  RewardSovStaked
  """
  When an SOV Staker withdraws their share of the fees earned by the Protocol
  """
  UserFeeWithdrawn
}

type RewardsEarnedHistoryItem @entity {
  id: ID! # transaction hash + RewardEarnedAction
  action: RewardsEarnedAction!
  user: UserRewardsEarnedHistory!
  token: Token
  amount: String!
  timestamp: Int!
  transaction: Transaction!
}

"""
This entity has only one instance (id: 0), and holds global variables required for liquidity mining rewards calculations
"""
type LiquidityMiningGlobal @entity {
  id: ID! # ID will be 0
  """
  Total available allocation points. This is used to calculated the reward per block for each pool token.
  See the LiquidityMiningAllocationPoint entity for more details.
  """
  totalAllocationPoint: String!
  """
  Total possible SOV per block in the liquidity mining program. Not all of this has to be allocation (eg if totalRewardPerBlock = 1000, that does not mean 1000 SOV are being given to LPs per block)
  This is used to calculated the reward per block for each pool token.
  See the LiquidityMiningAllocationPoint entity for more details.
  """
  totalRewardPerBlock: String!
}

type LiquidityMiningAllocationPoint @entity {
  id: ID! # token address
  allocationPoint: String!
  """
  The amount of SOV earned per block by all LPs in one pool
  Calculated as (totalRewardPerBlock * allocationPoint) / totalAllocationPoint
  """
  rewardPerBlock: String!
  """
  If this pool token is for an AMM liquidity pool, this is a foreign key to the SmartToken.
  If not, this property is null
  """
  ammPoolToken: SmartToken
  """
  If this pool token is for a lending pool, this is a foreign key to the LendingPool.
  If not, this property is null
  """
  lendingPoolToken: LendingPool
  """
  Unix timestamp for when this pool token was added to the liquidity mining program
  """
  poolTokenAddedTimestamp: Int!
  """
  Unix timestamp for when the allocation point for this pool token last changed
  """
  poolTokenUpdatedTimestamp: Int!
  poolTokenAddedBlock: Int!
  poolTokenUpdatedBlock: Int!
}

# Settlement contract scaffolded events (for Limit Orders)

type Deposit @entity {
  id: ID!
  to: String! # address
  amount: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

type MarginOrderCanceled @entity {
  id: ID!
  hash: String! # bytes32
  trader: String! # address
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

type MarginOrderFilled @entity {
  id: ID!
  hash: String! # bytes32
  trader: User! # address
  principal: String! # uint256
  collateral: String! # uint256
  leverageAmount: String! # uint256
  loanTokenAddress: String! # address
  loanTokenSent: String! # uint256
  collateralTokenSent: String! # uint256
  collateralTokenAddress: String! # address
  filledPrice: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

type OrderCanceled @entity {
  id: ID!
  hash: String! # bytes32
  maker: String! # address
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

type OrderFilled @entity {
  id: ID!
  hash: String! # bytes32
  maker: User! # address
  amountIn: String! # uint256
  amountOut: String! # uint256
  path: [String!]! # address[]
  filledPrice: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

type Withdrawal @entity {
  id: ID!
  receiver: String! # address
  amount: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
This is an event emitted from the staking contract when tokens are staked, either by a user or by a vesting contract
If tokens are staked by a vesting contract, there may be multiple tokens staked event per transaction (eg if tokensa are vested over 10 months, there would be 10 TokensStaked events each with a different lockedUntil date)
We have improvements planned to better represent staking on our subgraph.
"""
type TokensStaked @entity {
  """
  ID is transaction hash + log index
  """
  id: ID!
  """
  If tokens were staked by a vesting contract, user property will be null
  """
  user: User
  """
  The staker is either a user address or a vesting contract address
  """
  staker: String! # address
  """
  The amount of SOV staked in this event (as mentioned above, there can be multiple TokensStaked events per transaction)
  """
  amount: String! # uint256
  """
  The date when these tokens will unlock
  A user/vesting contract can have multiple stakes with different lockedUntil dates
  """
  lockedUntil: Int! # uint256
  """
  The total amount staked for this specific user until this specific lockedUntil date
  """
  totalStaked: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
  """
  If this is false, the tokens were staked by a vesting contract, and not voluntarily by a user
  """
  isUserStaked: Boolean!
}

"""
This entity holds the voluntary staking history (ie not staking by a vesting contract) of one user
"""
type UserStakeHistory @entity {
  """
  ID is the user address
  """
  id: ID! # id is user
  user: User!
  """
  Granular history of the user's voluntary staking activity
  """
  stakeHistory: [StakeHistoryItem!] @derivedFrom(field: "user")
  """
  totalStaked is the total amount the user has EVER staked (over all time).
  Eg if they stake 10 SOV and then withdraw it and stake it again, totalStaked is 20 SOV
  """
  totalStaked: String!
  """
  totalWithdrawn is the total amount the user has ever withdrawn from voluntary staking (over all time)
  """
  totalWithdrawn: String!
  """
  totalRemaining is the amount the user currently has staked.
  It should be the same as the result of calling the balanceOf(USER_ADDRESS) method on the staking contract.
  """
  totalRemaining: String!
}

enum StakeHistoryAction {
  """
  Voluntarily staking SOV (ie not staked through a vesting contract)
  """
  Stake
  """
  Increasing the amount of an existing stake. The lockedUntil date of this stake remains the same, but amount increases.
  """
  IncreaseStake
  """
  Extending an existing stake. The amount of the stake remains the same, but the lockedUntil date increases.
  """
  ExtendStake
  """
  When a user delegates voting power to another user. This can also be for voting power that the user has through a vesting contract.
  """
  Delegate
  """
  Unstake is early unstaking, when a user withdraws staked SOV before the lockedUntil date and incurs a slashing penalty.
  """
  Unstake
  """
  WithdrawStaked is when a user withdraws SOV from the staking contract after the unlock date, when the funds are no longer staked or locked
  """
  WithdrawStaked
  """
  When a user withdraws their share of the Protocol fees that is shared amongst stakers
  """
  FeeWithdrawn
}

"""
This entity is the granular history of user actions related to voluntary staking
"""
type StakeHistoryItem @entity {
  id: ID! # transaction hash
  user: UserStakeHistory!
  action: StakeHistoryAction!
  timestamp: Int!
  transaction: Transaction!
  amount: String
  lockedUntil: Int
}

# This event is emitted when tokens are transferred to the Protocol contract as fees
# It is needed because this is a flag for if staked tokens were unstaked early

type FeeSharingTokensTransferred @entity {
  id: ID! # ID is tx hash - it can't be tx hash + log index because we need to load on tx hash
  sender: String!
  token: String!
  amount: String!
}

# USER SCHEMA

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User @entity {
  """
  ID is user wallet address
  """
  id: ID!
  """
  Timestamp of User's first interaction with the protocol (first transaction)
  """
  createdAtTimestamp: Int!
  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps: [Swap!] @derivedFrom(field: "user")
  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory: [UserLiquidityHistory!] @derivedFrom(field: "user")
  """
  An array of margin trade Trade events
  """
  trades: [Trade!] @derivedFrom(field: "user")
  """
  An array of Borrow events
  """
  borrows: [Borrow!] @derivedFrom(field: "user")
  """
  An array of Liquidation events linked to this user
  """
  liquidations: [Liquidate!] @derivedFrom(field: "user")
  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans: [Loan!] @derivedFrom(field: "user")
  """
  The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events.
  """
  lendingHistory: [UserLendingHistory!] @derivedFrom(field: "user")
  """
  The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory: [UserStakeHistory!] @derivedFrom(field: "user")
  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory: [UserRewardsEarnedHistory!] @derivedFrom(field: "user")
  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts: [VestingContract!] @derivedFrom(field: "user")
  """
  Voting history of User
  """
  votes: [VoteCast!] @derivedFrom(field: "voter")
  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotal @derivedFrom(field: "user")
  """
  FastBTCBridge transfers from BTC to RSK
  """
  bitcoinTransfers: [BitcoinTransfer!] @derivedFrom(field: "user")
  fastBTCBridgeStats: [FastBTCBridgeStat!] @derivedFrom(field: "user")
  """
  Cross ChainBridge transfers from RSK and to RSK
  """
  receivedCrossChainTransfers: [CrossTransfer!]!
  sentCrossChainTransfers: [CrossTransfer!]!
  """
  Transactions initiated by this user
  """
  transactions: [Transaction!] @derivedFrom(field: "from")
}

"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotal @entity {
  id: ID!
  user: User!
  totalMarginTradeVolumeUsd: String!
  totalCloseWithSwapVolumeUsd: String!
  totalDepositCollateralVolumeUsd: String!
  totalLiquidateVolumeUsd: String!
  totalAmmVolumeUsd: String!
  totalAmmLpFeesUsd: String!
  totalAmmStakerFeesUsd: String!
  totalTradingFeesUsd: String!
  totalLendingFeesUsd: String!
  totalBorrowingFeesUsd: String!
  totalLendVolumeUsd: String!
  totalUnlendVolumeUsd: String!
  totalBorrowVolumeUsd: String!
  totalCloseWithDepositVolumeUsd: String!
  # totalTransactedVolumeUsd: String! # TODO: Implement
}

# Vesting Registry

enum VestingContractType {
  """
  Vesting contracts for investors who participated in the Sovryn Origin sale
  """
  Origins
  """
  Vesting contracts for investors who participated in the Sovryn Genesis sale
  """
  Genesis
  """
  FISH (Babelfish governance token) vesting contracts
  """
  Fish
  """
  Babelfish team vesting contracts
  """
  FishTeam
  """
  Sovryn team vesting contracts
  """
  Team
  """
  Vesting contracts for vested rewards
  """
  Rewards
  """
  Vesting contracts for strategic investors with a four-year lockup
  """
  FourYearVesting
  """
  Vesting contracts for early strategic investors
  """
  Strategic
}

"""
This entity represents one vesting contract
A User can have multiple vesting contracts
"""
type VestingContract @entity {
  """
  ID is the vesting contract address
  """
  id: ID! # vesting contract id
  """
  The owner of the vesting contract
  """
  user: User!
  """
  Date that the vesting contract was created
  """
  createdAtTimestamp: Int!
  """
  The cliff is the period (in seconds) until the first tokens become liquid on this contract
  """
  cliff: Int # uint256
  """
  The total duration of the vesting contract, including the cliff, in seconds.
  For example, a 9 month vesting contract with a 1 month cliff would have a duration of 26280000 (10 months in seconds)
  """
  duration: Int # uint256
  """
  The initial balance when this contract was created. This is often 0, as tokens can be added to the contract after contract creation
  """
  startingBalance: String! # uint256
  """
  Current balance of tokens on the contract, including locked and liquid tokens that have not been withdrawn.
  Incremented on TokensStaked actions, decremented on TokensWithdrawn actions
  """
  currentBalance: String!
  """
  Type of contract (see VestingContractType docs for more details)
  """
  type: VestingContractType!
  emittedBy: String!
  createdAtTransaction: Transaction!
  """
  A granular history of every action involving this vesting contract
  """
  stakeHistory: [VestingHistoryItem!] @derivedFrom(field: "staker")
}

enum VestingHistoryItemAction {
  """
  Tokens are staked by the Vesting contract. This happens when the Vesting contract receives funds.
  """
  TokensStaked
  """
  This is only relevant to Team tokens. For Team contracts, a vesting contract can be revoked by governance if a team member leaves the project.
  If this happens, all tokens still locked are returned to the exchequer.
  This is ONLY possible with Team or FishTeam vesting contracts.
  """
  TeamTokensRevoked
  """
  When a user withdraws unlocked tokens from the vesting contract
  """
  TokensWithdrawn
}

"""
Granular data for each vesting contract, and any actions involving that contract
"""
type VestingHistoryItem @entity {
  """
  ID is transaction hash + "-" + log index
  For TokensStaked actions, there can be multiple actions per transactions, and each will create a new entity
  """
  id: ID!
  action: VestingHistoryItemAction!
  """
  The staker here will always be the vesting contract
  """
  staker: VestingContract!
  """
  Amount being staked
  """
  amount: String! # uint256
  """
  The date when the tokens become unlocked
  """
  lockedUntil: Int! # uint256
  """
  Total number of tokens staked until this lockedUntil date
  """
  totalStaked: String! # uint256
  timestamp: Int!
  emittedBy: String! #address
  transaction: Transaction!
}
